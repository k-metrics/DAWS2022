# 度数分布表とヒストグラムでデータの特徴を浮き彫りにする


## 生データでは何もわからないから統計を使う
　テキストの図表1-1のデータは4列20行からなるデータです。
```{r, echo=FALSE, message=FALSE}
"../data/P16_図表1-1 .csv" %>% 
  readr::read_csv(col_names = FALSE, show_col_types = FALSE)
```

　Rでは、このような形式のデータ（雑然データ）をそのまま使わずに整然データ（[Tidy Data](https://ja.wikipedia.org/wiki/Tidy_data)）と呼ばれる形式に変換した方が効率的に処理できます。変換には**`tidyverse`**ファミリーを利用するのが効率的です。
```{r}
library(tidyverse)

# ローカルにあるデータファイルを読み込む
x <- "../data/P16_図表1-1 .csv" %>% 
  readr::read_csv(col_names = FALSE, show_col_types = FALSE) %>% 
  # 読み込んだデータを縦長形式（Tidy Data）に変換する
  tidyr::pivot_longer(cols = dplyr::starts_with("X"),
                      names_to = "name", values_to = "value") %>% 
  # X1, X2, ... , X4, X1 の順で行方向に読み込まれるので列方向で整列する
  dplyr::arrange(name) %>% 
  # 必要なデータ列（value）の列名をheightに変更して取り出す
  dplyr::select(height = value)

x
```

　このような形式に変換することで、様々な統計量を効率的に求めることができるようになります。  

　  

## ヒストグラムを作る
　テキストでは度数分布表を作成してからヒストグラムを描いています。その手順は

1. 最大・最小値を求める
1. 階級を決める
1. 度数をカウントする
1. 相対度数を求める
1. 累積度数を求める
    * ここまでで度数分布表ができる
1. 度数分布表をもとにヒストグラムを描く

となっていますが、Rでは`hist()`関数だけでヒストグラムを描くことができます。`hist()`関数の引数はベクトル型に限定されますので、データフレーム型の場合は参照演算子（`$`）などでベクトル型データを取り出す必要があります。
```{r}
hist(x = x$height)
```
　`hist()`関数はヒストグラムを描くために必要となる階級や度数、階級値などの情報を出力することも可能です。
```{r}
hist(x = x$height, plot = FALSE)
```

: 主な出力の意味

出力名     | 意味   | 備考
-----------|--------|-------------------------------------------------
`$breaks`  | 階級   | デフォルトはスタージェスの公式^\*^にもとづく区切り（幅）
`$counts`  | 度数   | 各階級に入るデータの個数
`$density` | 密度   | 密度推定値
`$mids`    | 階級値 | 階級の中央値（階級の単純平均）

^\*^ 後述


　表形式の度数分布表を作成する場合は以下のようにコード処理します。
```{r}
x %>% 
  # 階級を求めて、データを階級ごとに分ける
  dplyr::mutate(class = cut(height,
                            breaks = pretty(height, n = nclass.Sturges(height)),
                            include.lowest = FALSE, right = TRUE)) %>% 
  # 階級ごとの度数を求める
  dplyr::count(class) %>% 
  # 累積度数、相対度数、累積相対度数を求める
  dplyr::mutate(cumsum_n = cumsum(n),
                prop = prop.table(n), cumsum_prop = cumsum(prop)) %>% 
  # 階級値を求める
  dplyr::mutate(class_value = as.character(class)) %>%
  tidyr::separate(class_value, into = c("l", "h"), sep = ",") %>% 
  dplyr::mutate(l = as.integer(stringr::str_remove(l, "[[:punct:]]")) + 1L,
                h = as.integer(stringr::str_remove(h, "[[:punct:]]")),
                mids = (l + h) / 2L) %>%
  # 変数名を日本語にする
  dplyr::select(`階級` = class, `階級値` = mids,
                `度数` = n, `累積度数` = cumsum_n,
                `相対度数` = prop, `累積相対度数` = cumsum_prop)
```

　以降の項は度数分布表の作成に必要な関数の使い方を紹介していますので、不要な方は演習問題まで読み飛ばしてください。

　  

### 階級を求める

> 以降に出てくる`with()`関数は、第一引数で指定するデータフレーム型変数内の変数名を第二引数内で参照演算子（`$`）を用いることなく参照できるようにする関数です。

　階級を求めるには`pretty()`関数を使います。

```{r}
with(x, pretty(x = height, n = nclass.Sturges(height)))
```

　第一引数`x`には階級を求めたいベクトル型データを第二引数`n`には階級を区切りたい数（階級数）を指定します。ここでは、階級数`n`にはスタージェスの公式から求めた階級数を指定しています。\
　ただし、必ずしも指定した階級数に分割される訳ではない点に注意してください。`x`で指定したデータが階級に収まるように適切な丸め処理を行いますので、指定した階級数とは異なる階級が求められることもあります。

　スタージェスの公式は、階級数を$k$、データのサイズ（数）を$n$とした場合、下式で定義されます。

$$k = \lceil \log_2n + 1 \rceil$$

　スタージェスの公式は`nclass.Sturgess()`関数として実装されています。

```{r}
with(x, nclass.Sturges(height))
```

　スタージェスの公式はヒストグラムを平滑化し過ぎる傾向があると言われています。気になる場合はスコットの選択（`nclass.scott()`）やフリードマン=ダイアコニスの選択（`nclass.FD()`）を試して見てください。

　

### データを各階級に分類する

　データを階級分けするには`cut()`関数を使います。

```{r}
with(x, cut(x = height, breaks = pretty(height, n = nclass.Sturges(height))))
```

　第一引数`x`には階級分けの対象となるベクトル型変数を第二引数`breaks`には前項で求めた階級を指定します。`breaks`引数には任意の階級、例えば`breaks = c(140, 155, 170) `のように指定することも可能です。

　

#### 階級の境界値はどちらに含まれるのか？ {.unnumbered}

　`cut()`関数の出力は、`(140,145] (145,150]`のように階級間で同じ数値、この場合は`145`が含まれます。では、`145`はどちらの階級に含まれるのでしょうか？答えは、添えられている括弧にあります。

> `(140,145]`

は「140を超えて145以下」となりますので、次の

> `(145,150]`

は同様に「145を超えて150以下」となります。階級間の境界値である`145`は`(140, 145]`側に入ります。

> `(`は「超えて」（境界値を含まない）、`]`は「以下」（境界値を含む）

で、逆向きの場合は

> `)`は「未満」（境界値を含まない）、`[`は「以上」（境界値を含む）

となります。`hist()`関数の階級も同様です。

　境界値をどちらに含めるかは`include.lowest`引数と`right`引数で指定できます。

| option                       | `right = TRUE` 　     | `right = FALSE`   |
|------------------------------|-----------------------|-------------------|
| **`include.lowest = TRUE`**  | `[l,u] ... (l,u]`     | `[l,u) ... [l,u]` |
| **`include.lowest = FALSE`** | `(l,u] ... (l,u]`^\*^ | `[l,u) ... [l,u)` |

　^\*^デフォルト

　例えばデータの最大値と最小値を境界値として含む階級を指定した場合、`include.lowest = FALSE, right = FALSE`と指定すると最大値が階級に含まれなくなります。

```{r}
with(x, cut(height, breaks = c(143, 155, 169),
            include.lowest = FALSE, right = FALSE))
```

　逆に`include.lowest = FALSE, right = TRUE`と指定すると最小値が階級に含まれなくなります。

```{r}
with(x, cut(height, breaks = c(143, 155, 169),
            include.lowest = FALSE, right = TRUE))
```

　

### 度数を求める

　度数を求めるには各階級の数を数えます。数を数えるには`table()`関数や`dplyr::count()`関数を使います。`table()`関数はベクトル型を対象に、`dplyr::count()`関数はデータフレーム型を対象として個数をカウントします。用途によって使い分けてください。

```{r}
with(x, table(cut(height, breaks = pretty(height, n = nclass.Sturges(height)))))
```

　

```{r}
x %>% 
  # 階級を求めて、データを階級ごとに分ける
  dplyr::mutate(class = cut(height,
                            breaks = pretty(height, n = nclass.Sturges(height)))) %>% 
  # 階級ごとの度数を求める
  dplyr::count(class)
```

　

### 累積度数、相対度数、累積相対度数を求める

　累積度数（度数の累積和）を求めるには`cumsum()`関数を使います。

```{r}
with(x, cumsum(table(cut(height, breaks = pretty(height, n = nclass.Sturges(height))))))
```

　

　相対度数を求めるには`prop.table()`関数を使います。

```{r}
with(x, prop.table(table(cut(height, breaks = pretty(height, n = nclass.Sturges(height))))))
```

　

　累積相対度数は相対度数の累積和ですので、`prop.table()`関数の結果を`cumsum()`関数に渡すことで求めることができます。

```{r}
with(x, cumsum(prop.table(table(cut(height, breaks = pretty(height, n = nclass.Sturges(height)))))))
```

　

### 階級値を求める

　階級値は階級の文字列から下端と上端の境界値を抜き出し、下式で単純平均として求めています。

$$\frac{(\mbox{下端} + 1) + \mbox{上端}}{2}$$

　手順としては以下のようにしています。

1.  `as.character()`関数で 階級（`class`）を文字型に変換し、新しい変数（`class_value`）を作成する\
2.  `tidyr::separate()`関数で文字型の変数（`class_value`）を`,`の前後で二つの変数（`l`, `h`）に分割する\
3.  `stringr::str_remove`関数で二つの変数（`l`, `h`）から`(`や`]`を取り除き`as.numeric()`関数で文字列から数値に変換する\
4.  数値に変換された二つの変数から（`l`, `h`）平均値を求める

```{r}
x %>% 
  # 階級を求めて、データを階級ごとに分ける
  dplyr::mutate(class = cut(height,
                            breaks = pretty(height, n = nclass.Sturges(height)),
                            include.lowest = FALSE, right = TRUE)) %>% 
  # 階級ごとの度数を求める
  dplyr::count(class) %>% 
  # 階級値を求める
  dplyr::mutate(class_value = as.character(class)) %>% 
  tidyr::separate(class_value, into = c("l", "h"), sep = ",") %>% 
  dplyr::mutate(l = as.numeric(stringr::str_remove(l, "[[:punct:]]")),
                h = as.numeric(stringr::str_remove(h, "[[:punct:]]"))) %>% 
  dplyr::mutate(mids = ((l + 1) + h) / 2)
```

　

## 練習問題

　テキストP23にあるデータで度数分布表とヒストグラムを作成する。

```{r, echo=FALSE, message=FALSE}
df <- "../data/P23_図表1-4.csv" %>% 
  readr::read_csv(col_names = FALSE)
df
```

　

### 解答例 {.unnumbered}

　まず、処理しやすいように下記のように対象データを変形し`df`というデータフレーム型の変数に格納しておきます。

```{r, echo=FALSE}
df <- df %>% 
  tidyr::pivot_longer(cols = starts_with("X")) %>% 
  dplyr::arrange(name) %>% 
  dplyr::mutate(weight = as.integer(value)) %>% 
  dplyr::select(weight)
```

```{r}
df
```

　度数分布表を身長の場合と同じ要領で作成します。

```{r}
df %>% 
  # 階級を求めて、データを階級ごとに分ける
  dplyr::mutate(class = cut(weight,
                            breaks = pretty(weight, n = nclass.Sturges(weight)),
                            include.lowest = FALSE, right = TRUE)) %>% 
  # 階級ごとの度数を求める
  dplyr::count(class) %>% 
  # 累積度数、相対度数、累積相対度数を求める
  dplyr::mutate(cumsum_n = cumsum(n),
                prop = prop.table(n), cumsum_prop = cumsum(prop)) %>% 
  # 階級値を求める
  dplyr::mutate(class_value = as.character(class)) %>%
  tidyr::separate(class_value, into = c("l", "h"), sep = ",") %>% 
  dplyr::mutate(l = as.integer(stringr::str_remove(l, "[[:punct:]]")) + 1L,
                h = as.integer(stringr::str_remove(h, "[[:punct:]]")),
                mids = (l + h) / 2L) %>%
  # 変数名を日本語にする
  dplyr::select(`階級` = class, `階級値` = mids,
                `度数` = n, `累積度数` = cumsum_n,
                `相対度数` = prop, `累積相対度数` = cumsum_prop)
```

　

　ヒストグラムを描きます。

```{r}
with(df, hist(weight))
```

　

以上

　  

## ヒストグラムを描くポイント {.unnumbered}

　ヒストグラムを描く（度数分布表を作成する）際のポイントは下記の二点があります。

1. 階級の決め方
1. 階級の境界の扱い

　  

### 階級の決め方 {.unnumbered}

　階級を決める方法は特に定められていません。データが取る幅を見て切のよい値にすることが多いようです。ただし、階級のとり方によりヒストグラムの形状が変わる点には注意が必要です。例えば、身長データに対する階級をテキストと同様に$5cm$幅とした場合は下図のような形状になります。
```{r}
with(x, hist(height, breaks = seq(from = 140, to = 170, by = 5)))
```

　階級を倍の$10cm$幅とすると下図のようになります。
```{r}
with(x, hist(height, breaks = seq(from = 140, to = 170, by = 10)))
```

　逆に階級を半分の$2.5cm$幅とすると下図のようになります。
```{r}
with(x, hist(height, breaks = seq(from = 140, to = 170, by = 2.5)))
```

　更に細かくして$1cm$幅にすると下図のように歯抜けがある形状になります。
```{r}
with(x, hist(height, breaks = seq(from = 140, to = 170, by = 1.0)))
```

　このように階級の決め方次第でヒストグラムの形状が変わってくることが分かります。ヒストグラムはデータの分布をみるために使うグラフですので、過大な階級幅や過小な階級幅で描くことは好ましくありませんので、適切な値を選ぶようにしてください。

　  

#### 計算で階級を決める {.unnumbered}

　適切な階級をどのように決めれば良いか迷う場合には、下表のような計算方法が提案されていますのでこれらを試してみてください。


階級の求め方                            | 階級数（$k$）・階級幅（$h$）           | 備考
----------------------------------------|----------------------------------------|-------------
平方根選択（Square-root choice）        | $k = \sqrt{n}$                         | 
スタージェスの公式（Sturges's formula） | $k = \lceil \log_2n + 1 \rceil$        | $n \geq 30$が前提
スコットの選択（Scott's choice）        | $h = \frac{3.5\sigma}{n^{1/3}}$        | 
フリードマン・ダイアコニスの選択（F-D's choice） | $h = 2\frac{IQR(x)}{n^{1/3}}$ | 

 階級数（$k$）から階級幅（$h$）を求める場合は下式を使います。
$$h = \lceil \frac{max(x) - min(x)}{k} \rceil$$
$k$ :階級の数  
$h$ :階級の幅  
$n$ :データの個数  
$\lceil x \rceil$ :天井関数（実数$x$に対して$x$以上の最小の整数を返す関数）  
$\sigma$ :標準偏差  
$IQR$ :四分位範囲  

数式出典：[Wikipedia](https://ja.wikipedia.org/wiki/%E3%83%92%E3%82%B9%E3%83%88%E3%82%B0%E3%83%A9%E3%83%A0#%E9%9A%8E%E7%B4%9A%E3%81%AE%E5%80%8B%E6%95%B0%E3%81%A8%E5%B9%85)

　  

##### スタージェスの公式 {.unnumbered}

　スタージェスの公式は、比較的、よく使われる計算方法です。ただし、データの数が$30$個未満の場合には適切ではありませんし、データの数が多くなるとヒストグラムを[平滑化し過ぎる傾向](https://k-metrics.netlify.app/post/2018-09/histogram/#/%E4%BB%BB%E6%84%8F%E3%81%AE%E9%9A%8E%E7%B4%9A%E3%82%92%E6%8C%87%E5%AE%9A%E3%81%99%E3%82%8B)があると言われています。そのような傾向が見られた場合には、他の計算方法や任意の階級も試してみてください。
```{r}
with(x, hist(height, breaks = "Sturges"))
```

　  

##### スコットの選択 {.unnumbered}

　スコットの選択は、データによってはスタージェスの公式と比べて階級数が少なくなる傾向があります。
```{r}
with(x, hist(height, breaks = "Scott"))
```

　  

##### フリードマン・ダイアコニスの選択 {.unnumbered}

　フリードマン・ダイアコニスの法則とも呼ばれます。
```{r}
with(x, hist(height, breaks = "FD"))
```

　  

### 階級の境界の扱い {.unnumbered}

　階級は下表のように「下端値〜上端値」の形式で表示されることが多いですが、$140$は階級に含まれるのか？$145$はどちらの階級に含まれるのか？を決めておかないと意図しない度数になってしまう場合があります。


階級     | 度数 | 
---------|-----:|
140〜145 | 1
145〜150 | 6
...      | ...
160〜165 | 16
165〜170 | 6

　例えば、階級を「$\mbox{下端値} \lt x \leq \mbox{上端値}$」と定義した場合は、下図のようになります。
```{r}
with(x, hist(height, right = TRUE))
```

 階級を「$\mbox{下端値} \leq x \lt \mbox{上端値}$」と定義した場合は、分布形状が異なることが分かります。
```{r}
with(x, hist(height, right = FALSE))
```

　このように階級によりヒストグラムの形状が変わってくる点には注意が必要です。なお、下端、上端の含め方を[「左閉じ、右閉じ」と表現](https://k-metrics.netlify.app/post/2018-09/histogram/#/%E5%B7%A6%E9%96%89%E3%81%98%E3%81%A8%E5%8F%B3%E9%96%89%E3%81%98)することもあります。

