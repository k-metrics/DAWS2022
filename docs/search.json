[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Rで学ぶ『完全独習 統計学入門』",
    "section": "",
    "text": "本資料は『完全独習 統計学入門』小島寛之著（以降、テキスト）の内容をRで計算する方法を紹介しています1。テキストに記載されているデータの一部をCSVファイルに起こして利用していますが、データ自体の著作権は原著作者にあります。また、CSVファイルは著作権を侵害する意図で作成したものではありません。1 Rのインストール方法や基本文法などには触れません\n　\n\n　本書の想定読者は以下に該当する方です。\n\nRに関する基本的な知識を有している方\n\nデータフレーム型や因子型などの変数型の知識\n変数の代入・参照方法\n\ntidyverseの基本的な知識（パイプ演算子など）\n\n\nRで統計量を求めてみたい方\n\n　\n\n\n\n\n\n\ndf_print()関数について\n\n\n\n　本書のコードに出てくるdf_pirnt()関数はデータフレームを出力フォーマットごとに適切な形式で出力するために定義した関数です。RやCRANのパッケージで提供されている関数ではありません。ご自身の環境でコードを実行する際にはdf_print()関数とその直前のパイプ演算子（%>%）を削除してから実行してください。\n　例）x %>% df_printとなっている場合は%>% df_print()を削除しxを実行してください。\n\n\n　\n\n\n\n\n\n\nTip: Index\n\n\n\n　左側に章単位のインデックス（以降、メインインデックス）、右側に現在表示中のページ内のインデックス（以降、サブインデックス）が表示されます。インデックスはウィンドウサイズにより表示位置などが自動的に切り替わります。\n\n\n\n\n\n\n\n\nTip: Code Block Operation\n\n\n\n　コードブロックの上にある▼マークをクリックするとコードの表示・非表示を切り替えることができます。また、コードブロック中のパッケージ名や関数名にマウスオーバーした際に下線が表示されるものは、クリックをすると説明ページ（英語）にジャンプできます。 　コードブロック右上にあるアイコンをクリックするとコードをクリップボードにコピーできます。"
  },
  {
    "objectID": "chapter01.html",
    "href": "chapter01.html",
    "title": "\n1  度数分布表とヒストグラムでデータの特徴を浮き彫りにする\n",
    "section": "",
    "text": "テキストP16の図表1-1のデータは4列20行からなるデータです。\n\n\n\n\n  \n\n\n\n　\n　Rでは、このような形式のデータ（雑然データ）をそのまま使わずに整然データ（Tidy Data）と呼ばれる形式に変換した方が効率的に処理できます。変換にはtidyverseファミリーを利用するのが効率的です。\n\nTidy Dataへの変形library(tidyverse)  # load tidyverse package\n\nx <- \"./data/P16_図表1-1 .csv\" %>% \n  readr::read_csv(col_names = FALSE, show_col_types = FALSE) %>% \n  tidyr::pivot_longer(cols = dplyr::starts_with(\"X\"),\n                      names_to = \"name\", values_to = \"value\") %>% \n  dplyr::arrange(name) %>% \n  dplyr::select(height = value)\n\nx %>% \n  df_print()\n\n\n\n  \n\n\n\n　このような形式（Tidy Data）に変換することで、様々な統計量を効率的に求めることができるようになります。"
  },
  {
    "objectID": "chapter01.html#ヒストグラムを作る",
    "href": "chapter01.html#ヒストグラムを作る",
    "title": "\n1  度数分布表とヒストグラムでデータの特徴を浮き彫りにする\n",
    "section": "\n1.2 ヒストグラムを作る",
    "text": "1.2 ヒストグラムを作る\n　テキストでは度数分布表を作成してからヒストグラムを描いています。その手順は\n\n最大・最小値を求める\n階級を決める\n度数をカウントする\n相対度数を求める\n累積度数を求める\n\nここまでが度数分布表の作成\n\n\n度数分布表をもとにヒストグラムを描く\n\nとなっていますが、Rではhist()関数だけでヒストグラムを描くことができます。hist()関数の引数はベクトル型に限定されますので、データフレーム型の場合は参照演算子（$）などでベクトル型データを取り出す必要があります。\n\nR標準のヒストグラム関数hist(x = x$height)\n\n\n\n\n　\n　hist()関数はヒストグラムを描くために必要となる階級や度数、階級値などの情報を出力することも可能です。\n\n階級などを表示させる方法hist(x = x$height, plot = FALSE)\n\n$breaks\n[1] 140 145 150 155 160 165 170\n\n$counts\n[1]  1  6 19 30 18  6\n\n$density\n[1] 0.0025 0.0150 0.0475 0.0750 0.0450 0.0150\n\n$mids\n[1] 142.5 147.5 152.5 157.5 162.5 167.5\n\n$xname\n[1] \"x$height\"\n\n$equidist\n[1] TRUE\n\nattr(,\"class\")\n[1] \"histogram\"\n\n\n\n主な出力の意味\n\n\n\n\n\n\n出力名\n意味\n備考\n\n\n\n$breaks\n階級\nデフォルトはスタージェスの公式*後述にもとづく区切り（幅）\n\n\n$counts\n度数\n各階級に入るデータの個数\n\n\n$density\n密度\n密度推定値\n\n\n$mids\n階級値\n階級の中央値（階級の単純平均）\n\n\n\n　\n　表形式の度数分布表を作成する場合は以下のようにコード処理します。\n\n度数分布表の作成x %>% \n  # 階級を求めて、データを階級ごとに分ける\n  dplyr::mutate(class = cut(height,\n                            breaks = pretty(height, n = nclass.Sturges(height)),\n                            include.lowest = FALSE, right = TRUE)) %>% \n  # 階級ごとの度数を求める\n  dplyr::count(class) %>% \n  # 累積度数、相対度数、累積相対度数を求める\n  dplyr::mutate(cumsum_n = cumsum(n),\n                prop = prop.table(n), cumsum_prop = cumsum(prop)) %>% \n  # 階級値を求める\n  dplyr::mutate(class_value = as.character(class)) %>%\n  tidyr::separate(class_value, into = c(\"l\", \"h\"), sep = \",\") %>% \n  dplyr::mutate(l = as.integer(stringr::str_remove(l, \"[[:punct:]]\")) + 1L,\n                h = as.integer(stringr::str_remove(h, \"[[:punct:]]\")),\n                mids = (l + h) / 2L) %>%\n  # 変数名を日本語にする\n  dplyr::select(`階級` = class, `階級値` = mids,\n                `度数` = n, `累積度数` = cumsum_n,\n                `相対度数` = prop, `累積相対度数` = cumsum_prop) %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n　以降の項は度数分布表の作成に必要な関数の使い方を紹介していますので、不要な方は演習問題まで読み飛ばしてください。\n　\n\n1.2.1 階級を求める\n\n以降に出てくるwith()関数は、第一引数で指定するデータフレーム型変数内の変数名を第二引数内で参照演算子（$）を用いることなく参照できるようにする関数です。\n\n　階級を求めるにはpretty()関数を使います。\n\n階級を求めるwith(x, pretty(x = height,\n               n = nclass.Sturges(height)))\n\n[1] 140 145 150 155 160 165 170\n\n\n　第一引数xには階級を求めたいベクトル型データを第二引数nには階級を区切りたい数（階級数）を指定します。ここでは、階級数nにはスタージェスの公式から求めた階級数を指定しています。\n　ただし、xで指定したデータが階級に収まるように適切な丸め処理を行いますので、指定した階級数とは異なる階級が求められることもあります。\n　スタージェスの公式は、階級数を\\(k\\)、データのサイズ（数）を\\(n\\)とした場合、下式で定義されます。\n\\[k = \\lceil \\log_2n + 1 \\rceil\\]\n　スタージェスの公式はnclass.Sturgess()関数として実装されています。\n\nスタージェスの公式に基づく階級数with(x, nclass.Sturges(height))\n\n[1] 8\n\n\n　\n　スタージェスの公式はヒストグラムを平滑化し過ぎる傾向があると言われています。気になる場合はスコットの選択（nclass.scott()）やフリードマン=ダイアコニスの選択（nclass.FD()）を試して見てください。\n　\n\n1.2.2 データを各階級に分類する\n\n\n参考）身長データ（元データ）with(x, height)\n\n [1] 151 154 160 160 163 156 158 156 154 160 154 162 156 162 157 162 162 169 150\n[20] 162 152 161 159 164 168 153 160 155 160 158 160 150 163 155 157 162 154 161\n[39] 153 154 151 155 158 146 149 165 169 154 155 166 165 161 148 143 156 162 158\n[58] 156 159 164 167 159 157 151 159 156 151 160 153 156 146 166 151 159 157 156\n[77] 162 156 156 161\n\n　\n　データを階級分けするにはcut()関数を使います。\n\nデータの階級分けwith(x, cut(x = height,\n            breaks = pretty(height,\n                            n = nclass.Sturges(height))))\n\n [1] (150,155] (150,155] (155,160] (155,160] (160,165] (155,160] (155,160]\n [8] (155,160] (150,155] (155,160] (150,155] (160,165] (155,160] (160,165]\n[15] (155,160] (160,165] (160,165] (165,170] (145,150] (160,165] (150,155]\n[22] (160,165] (155,160] (160,165] (165,170] (150,155] (155,160] (150,155]\n[29] (155,160] (155,160] (155,160] (145,150] (160,165] (150,155] (155,160]\n[36] (160,165] (150,155] (160,165] (150,155] (150,155] (150,155] (150,155]\n[43] (155,160] (145,150] (145,150] (160,165] (165,170] (150,155] (150,155]\n[50] (165,170] (160,165] (160,165] (145,150] (140,145] (155,160] (160,165]\n[57] (155,160] (155,160] (155,160] (160,165] (165,170] (155,160] (155,160]\n[64] (150,155] (155,160] (155,160] (150,155] (155,160] (150,155] (155,160]\n[71] (145,150] (165,170] (150,155] (155,160] (155,160] (155,160] (160,165]\n[78] (155,160] (155,160] (160,165]\nLevels: (140,145] (145,150] (150,155] (155,160] (160,165] (165,170]\n\n\n　\n　cut()関数の第一引数xには階級分けの対象となるベクトル型変数を第二引数breaksには前項で求めた階級を指定します。breaks引数には任意の階級、例えばbreaks = c(140, 155, 170)のような指定も可能です。\n　\n階級の境界値はどちらに含まれるのか？\n　cut()関数の出力は、(140,145] (145,150]のように階級間で同じ値（この場合は145）が含まれます。では、145はどちらの階級に含まれるのでしょうか？答えは、添えられている括弧にあります。\n\n(140,145]\n\nは「140を超えて145以下」となりますので、次の\n\n(145,150]\n\nは同様に「145を超えて150以下」となります。階級間の境界値である145は(140, 145]側に入ります。\n\n(は「超えて」（境界値を含まない）、]は「以下」（境界値を含む）\n\nで、逆向きの場合は\n\n)は「未満」（境界値を含まない）、[は「以上」（境界値を含む）\n\nとなります。hist()関数の階級も同様です。\n　境界値をどちらに含めるかはinclude.lowest引数とright引数で指定できます。\n\n\n\n\n\n\n\noption\n\nright = TRUE 　\nright = FALSE\n\n\n\ninclude.lowest = TRUE\n[l,u] ... (l,u]\n[l,u) ... [l,u]\n\n\ninclude.lowest = FALSE\n\n(l,u] ... (l,u]*\n\n[l,u) ... [l,u)\n\n\n\n　*デフォルト\n　例えばデータの最大値と最小値を境界値として含む階級を指定した場合、include.lowest = FALSE, right = FALSEと指定すると最大値が階級に含まれなくなる場合があります。\n\n以上、未満の場合with(x, cut(height, breaks = c(143, 155, 169),\n            include.lowest = FALSE, right = FALSE))\n\n [1] [143,155) [143,155) [155,169) [155,169) [155,169) [155,169) [155,169)\n [8] [155,169) [143,155) [155,169) [143,155) [155,169) [155,169) [155,169)\n[15] [155,169) [155,169) [155,169) <NA>      [143,155) [155,169) [143,155)\n[22] [155,169) [155,169) [155,169) [155,169) [143,155) [155,169) [155,169)\n[29] [155,169) [155,169) [155,169) [143,155) [155,169) [155,169) [155,169)\n[36] [155,169) [143,155) [155,169) [143,155) [143,155) [143,155) [155,169)\n[43] [155,169) [143,155) [143,155) [155,169) <NA>      [143,155) [155,169)\n[50] [155,169) [155,169) [155,169) [143,155) [143,155) [155,169) [155,169)\n[57] [155,169) [155,169) [155,169) [155,169) [155,169) [155,169) [155,169)\n[64] [143,155) [155,169) [155,169) [143,155) [155,169) [143,155) [155,169)\n[71] [143,155) [155,169) [143,155) [155,169) [155,169) [155,169) [155,169)\n[78] [155,169) [155,169) [155,169)\nLevels: [143,155) [155,169)\n\n\n　\n　逆にinclude.lowest = FALSE, right = TRUEと指定すると最小値が階級が階級に含まれなくなる場合があります。\n\n超えて、以下の場合with(x, cut(height, breaks = c(143, 155, 169),\n            include.lowest = FALSE, right = TRUE))\n\n [1] (143,155] (143,155] (155,169] (155,169] (155,169] (155,169] (155,169]\n [8] (155,169] (143,155] (155,169] (143,155] (155,169] (155,169] (155,169]\n[15] (155,169] (155,169] (155,169] (155,169] (143,155] (155,169] (143,155]\n[22] (155,169] (155,169] (155,169] (155,169] (143,155] (155,169] (143,155]\n[29] (155,169] (155,169] (155,169] (143,155] (155,169] (143,155] (155,169]\n[36] (155,169] (143,155] (155,169] (143,155] (143,155] (143,155] (143,155]\n[43] (155,169] (143,155] (143,155] (155,169] (155,169] (143,155] (143,155]\n[50] (155,169] (155,169] (155,169] (143,155] <NA>      (155,169] (155,169]\n[57] (155,169] (155,169] (155,169] (155,169] (155,169] (155,169] (155,169]\n[64] (143,155] (155,169] (155,169] (143,155] (155,169] (143,155] (155,169]\n[71] (143,155] (155,169] (143,155] (155,169] (155,169] (155,169] (155,169]\n[78] (155,169] (155,169] (155,169]\nLevels: (143,155] (155,169]\n\n\n　\n\n1.2.3 度数を求める\n　度数を求めるには各階級の数を数えます。数を数えるにはtable()関数やdplyr::count()関数を使います。table()関数はベクトル型を対象として、dplyr::count()関数はデータフレーム型を対象として個数をカウントする関数です。\n\n度数のカウントwith(x, table(cut(height,\n                  breaks = pretty(height,\n                                  n = nclass.Sturges(height)))))\n\n\n(140,145] (145,150] (150,155] (155,160] (160,165] (165,170] \n        1         6        19        30        18         6 \n\n\n\n度数のカウント（データフレームの場合）x %>% \n  dplyr::mutate(class = cut(height,\n                            breaks = pretty(height,\n                                            n = nclass.Sturges(height)))) %>% \n  dplyr::count(class) %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n\n1.2.4 累積度数、相対度数、累積相対度数を求める\n　累積度数（度数の累積和）を求めるにはcumsum()関数を使います。\n\n累積度数を求めるwith(x, cumsum(table(cut(height,\n                         breaks = pretty(height,\n                                         n = nclass.Sturges(height))))))\n\n(140,145] (145,150] (150,155] (155,160] (160,165] (165,170] \n        1         7        26        56        74        80 \n\n\n　\n　相対度数を求めるにはprop.table()関数を使います。\n\n相対度数を求めるwith(x, prop.table(table(cut(height,\n                             breaks = pretty(height,\n                                             n = nclass.Sturges(height))))))\n\n\n(140,145] (145,150] (150,155] (155,160] (160,165] (165,170] \n   0.0125    0.0750    0.2375    0.3750    0.2250    0.0750 \n\n\n　累積相対度数は相対度数の累積和ですので、prop.table()関数の結果をcumsum()関数に渡すことで求めることができます。\n\n累積相対度数を求めるwith(x, cumsum(prop.table(\n  table(cut(height,\n            breaks = pretty(height,\n                            n = nclass.Sturges(height)))))))\n\n(140,145] (145,150] (150,155] (155,160] (160,165] (165,170] \n   0.0125    0.0875    0.3250    0.7000    0.9250    1.0000 \n\n\n　\n\n1.2.5 階級値を求める\n　階級値は階級の文字列から下端と上端の境界値を抜き出し、下式で単純平均として求めています。\n\\[\\frac{(\\mbox{下端} + 1) + \\mbox{上端}}{2}\\]\n　手順としては以下のようになります。\n\n\nas.character()関数で 階級（class）を文字型に変換し、新しい変数（class_value）を作成する\n\n\ntidyr::separate()関数で文字型の変数（class_value）を,の前後で二つの変数（l, h）に分割する\n\n\nstringr::str_remove関数で二つの変数（l, h）から(や]を取り除きas.numeric()関数で文字列から数値に変換する\n\n数値に変換された二つの変数から（l, h）平均値を求める\n\n\n階級値を求めるx %>% \n  # 階級を求めて、データを階級ごとに分ける\n  dplyr::mutate(class = cut(height,\n                            breaks = pretty(height,\n                                            n = nclass.Sturges(height)),\n                            include.lowest = FALSE,\n                            right = TRUE)) %>% \n  # 階級ごとの度数を求める\n  dplyr::count(class) %>% \n  # 階級値を求める\n  dplyr::mutate(class_value = as.character(class)) %>% \n  tidyr::separate(class_value, into = c(\"l\", \"h\"), sep = \",\") %>% \n  dplyr::mutate(l = as.numeric(stringr::str_remove(l, \"[[:punct:]]\")),\n                h = as.numeric(stringr::str_remove(h, \"[[:punct:]]\"))) %>% \n  dplyr::mutate(mids = ((l + 1) + h) / 2) %>% \n  df_print()"
  },
  {
    "objectID": "chapter01.html#練習問題",
    "href": "chapter01.html#練習問題",
    "title": "\n1  度数分布表とヒストグラムでデータの特徴を浮き彫りにする\n",
    "section": "\n1.3 練習問題",
    "text": "1.3 練習問題\n　テキストP23にあるデータで度数分布表とヒストグラムを作成する。\n\n\n\n\n  \n\n\n\n　\n解答例\n　まず、処理しやすいように下記のように対象データを変形しdfというデータフレーム型の変数に格納しておきます。\n\n\n\n\n整形済の処理対象データ（体重データ）df %>% \n  df_print()\n\n\n\n  \n\n\n\n　度数分布表を身長の場合と同じ要領で作成します。\n\n度数分布表の作成df %>% \n  dplyr::mutate(class = cut(weight,\n                            breaks = pretty(weight,\n                                            n = nclass.Sturges(weight)),\n                            include.lowest = FALSE,\n                            right = TRUE)) %>% \n  # 階級ごとの度数を求める\n  dplyr::count(class) %>% \n  # 累積度数、相対度数、累積相対度数を求める\n  dplyr::mutate(cumsum_n = cumsum(n),\n                prop = prop.table(n),\n                cumsum_prop = cumsum(prop)) %>% \n  # 階級値を求める\n  dplyr::mutate(class_value = as.character(class)) %>%\n  tidyr::separate(class_value, into = c(\"l\", \"h\"), sep = \",\") %>% \n  dplyr::mutate(l = as.integer(stringr::str_remove(l, \"[[:punct:]]\")) + 1L,\n                h = as.integer(stringr::str_remove(h, \"[[:punct:]]\")),\n                mids = (l + h) / 2L) %>%\n  # 変数名を日本語にする\n  dplyr::select(`階級` = class, `階級値` = mids,\n                `度数` = n, `累積度数` = cumsum_n,\n                `相対度数` = prop,\n                `累積相対度数` = cumsum_prop) %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n　ヒストグラムを描きます。\n\nヒストグラムを描くwith(df, hist(weight))\n\n\n\n\n　\n以上"
  },
  {
    "objectID": "chapter01.html#ヒストグラムを描くポイント",
    "href": "chapter01.html#ヒストグラムを描くポイント",
    "title": "\n1  度数分布表とヒストグラムでデータの特徴を浮き彫りにする\n",
    "section": "ヒストグラムを描くポイント",
    "text": "ヒストグラムを描くポイント\n　ヒストグラムを描く（度数分布表を作成する）際のポイントは下記の点です。\n\n階級の決め方\n階級の境界の扱い\n\n　\n階級の決め方\n　階級を決める方法は特に定められていません。データが取る幅を見て切のよい値にすることが多いようです。ただし、階級のとり方によりヒストグラムの形状が変わる点には注意が必要です。例えば、身長データに対する階級をテキストと同様に\\(5cm\\)幅とした場合は下図のような形状になります。\n\n階級幅5cmの場合のヒストグラムwith(x, hist(height,\n             breaks = seq(from = 140, to = 170, by = 5)))\n\n\n\n\n　\n　階級を倍の\\(10cm\\)幅とすると下図のようになります。\n\n階級幅10cmの場合のヒストグラムwith(x, hist(height,\n             breaks = seq(from = 140, to = 170, by = 10)))\n\n\n\n\n　\n　逆に階級を半分の\\(2.5cm\\)幅とすると下図のようになります。\n\n階級幅2.5cmの場合のヒストグラムwith(x, hist(height,\n             breaks = seq(from = 140, to = 170, by = 2.5)))\n\n\n\n\n　\n　更に細かくして\\(1cm\\)幅にすると下図のように歯抜けがある形状になります。\n\n階級幅1cmの場合のヒストグラムwith(x, hist(height,\n             breaks = seq(from = 140, to = 170, by = 1.0)))\n\n\n\n\n　\n　このように階級の決め方次第でヒストグラムの形状が変わってくることが分かります。ヒストグラムはデータの分布をみるために使うグラフですので、過大な階級幅や過小な階級幅で描くことは好ましくありませんので、適切な値を選ぶようにしてください。\n　\n計算で階級を決める\n　適切な階級をどのように決めれば良いか迷う場合には、下表のような計算方法が提案されていますのでこれらを試してみてください。\n\n\n\n\n\n\n\n階級の求め方\n階級数（\\(k\\)）・階級幅（\\(h\\)）\n備考\n\n\n\n平方根選択（Square-root choice）\n\\(k = \\sqrt{n}\\)\n\n\n\nスタージェスの公式（Sturges’s formula）\n\\(k = \\lceil \\log_2n + 1 \\rceil\\)\n\n\\(n \\geq 30\\)が前提\n\n\nスコットの選択（Scott’s choice）\n\\(h = \\frac{3.5\\sigma}{n^{1/3}}\\)\n\n\n\nフリードマン・ダイアコニスの選択（F-D’s choice）\n\\(h = 2\\frac{IQR(x)}{n^{1/3}}\\)\n\n\n\n\n階級数（\\(k\\)）から階級幅（\\(h\\)）を求める場合は下式を使います。 \\[h = \\lceil \\frac{max(x) - min(x)}{k} \\rceil\\] \\(k\\) :階級の数\\(h\\) :階級の幅\\(n\\) :データの個数\\(\\lceil x \\rceil\\) :天井関数（実数\\(x\\)に対して\\(x\\)以上の最小の整数を返す関数）\\(\\sigma\\) :標準偏差\\(IQR\\) :四分位範囲\n数式出典：Wikipedia\n　\nスタージェスの公式\n　スタージェスの公式は、比較的、よく使われる計算方法です。ただし、データの数が\\(30\\)個未満の場合には適切ではありませんし、データの数が多くなるとヒストグラムを平滑化し過ぎる傾向があると言われています。そのような傾向が見られた場合には、他の計算方法や任意の階級も試してみてください。\n\n階級数をスタージェスの公式で求めた場合のヒストグラムwith(x, hist(height,\n             breaks = \"Sturges\"))\n\n\n\n\n　\nスコットの選択\n　スコットの選択は、データによってはスタージェスの公式と比べて階級数が少なくなる傾向があります。\n\n階級数をスコットの選択を元に求めた場合のヒストグラムwith(x, hist(height, breaks = \"Scott\"))\n\n\n\n\n　\nフリードマン・ダイアコニスの選択\n　フリードマン・ダイアコニスの法則とも呼ばれます。\n\n階級数をフリードマン・ダイアコニスの選択を元に求めた場合のヒストグラムwith(x, hist(height, breaks = \"FD\"))\n\n\n\n\n　\n階級の境界の扱い\n　階級は下表のように「下端値〜上端値」の形式で表示されることが多いですが、\\(140\\)は階級に含まれるのか？\\(145\\)はどちらの階級に含まれるのか？を決めておかないと意図しない度数になってしまう場合があります。\n\n\n階級\n度数\n\n\n\n140〜145\n1\n\n\n145〜150\n6\n\n\n…\n…\n\n\n160〜165\n16\n\n\n165〜170\n6\n\n\n\n　例えば、階級を「\\(\\mbox{下端値} < x \\leq \\mbox{上端値}\\)」と定義した場合は、下図のようになります。\n\n階級の上端を含める場合のヒストグラムwith(x, hist(height, right = TRUE))\n\n\n\n\n階級を「\\(\\mbox{下端値} \\leq x < \\mbox{上端値}\\)」と定義した場合は、分布形状が異なることが分かります。\n\n階級の下端を含める場合のヒストグラムwith(x, hist(height, right = FALSE))\n\n\n\n\n　このように階級によりヒストグラムの形状が変わってくる点には注意が必要です。なお、下端、上端の含め方を「左閉じ、右閉じ」と表現することもあります。"
  },
  {
    "objectID": "chapter01.html#等間隔ではない階級",
    "href": "chapter01.html#等間隔ではない階級",
    "title": "\n1  度数分布表とヒストグラムでデータの特徴を浮き彫りにする\n",
    "section": "等間隔ではない階級",
    "text": "等間隔ではない階級\n　度数分布表の階級は必ずしも等間隔である必要はありません。例えば、下図の世帯貯蓄のように度数の小さい階級をまとめたヒストグラムをしばしば見かけます。等間隔でないは階級は（最小値と最大値で桁が数桁異なるなど）幅が広いデータにおいて、階級を細かくしたい場合や等幅の階級でグラフ化するとデータを読み取りにくい場合などに使われます。\n（出典：なるほど統計学園）\n　このように階級幅が等間隔でない場合には、柱（棒）の面積が度数に対応するように高さを調整する必要があります。\n　ヒストグラムは棒グラフとは異なり階級ごとの柱（棒）の面積が意味を持っています。高さは一般的に度数として表示されますが、密度として表示することもあります。高さ（密度）と幅（階級幅）を乗じたものが相対度数になります。相対度数は名前の通り度数に比例していますので、柱（棒）の面積が等しければ同じ度数ということを表します。\n　\n　例えば、テキストにある身長のデータの\\(140cm\\)から\\(150cm\\)をひとつの階級にまとめた場合、度数分布表は下表のようになります。\n\n等間隔ではない階級の度数分布表x %>% \n  dplyr::mutate(class = cut(height,\n                            breaks = c(140, 150,\n                                       155, 160, 165, 170))) %>% \n  dplyr::count(class) %>% \n  dplyr::mutate(prop = prop.table(n)) %>% \n  dplyr::rename(`階級` = class, `度数` = n,\n                `相対度数` = prop) %>% \n  df_print()\n\n\n\n  \n\n\n\n　これをヒストグラムとして描いた場合は、下図のようにならなければなりません。この図では縦軸は度数でなく密度になっています。\n\n正しいヒストグラムwith(x, hist(height,\n             breaks = c(140, 150, 155, 160, 165, 170)))\n\n\n\n\n　密度（高さ）は左から\n　　0.00875, 0.0475, 0.075, 0.045, 0.015\n　となっていますので、これに個々の階級幅（幅）\n　　10, 5, 5, 5, 5\n　を乗じると個々の柱（棒）の面積は\n　　0.0875, 0.2375, 0.375, 0.225, 0.075\n　となり、相対度数と等しいことがわかります。　\n　度数を表示させるために下図のようなヒストグラムを描くことは好ましくありません。階級幅が等幅でない場合は度数分布表と共に密度のヒストグラムを示した方がよいでしょう。\n\n好ましくないヒストグラム（単なる棒グラフ）with(x, hist(height,\n             breaks = c(140, 150, 155, 160, 165, 170),\n             freq = TRUE))\n\nWarning in plot.histogram(r, freq = freq1, col = col, border = border, angle =\nangle, : プロットの領域が誤まりです。むしろ 'freq = FALSE' を使用して下さい"
  },
  {
    "objectID": "chapter02.html",
    "href": "chapter02.html",
    "title": "\n2  平均値とはやじろべえの視点である\n",
    "section": "",
    "text": "本講では以下のデータフレームを利用しています。"
  },
  {
    "objectID": "chapter02.html#統計量はデータを要約する数値",
    "href": "chapter02.html#統計量はデータを要約する数値",
    "title": "\n2  平均値とはやじろべえの視点である\n",
    "section": "\n2.1 統計量は、データを要約する数値",
    "text": "2.1 統計量は、データを要約する数値\n　本講で扱っている統計量（要約統計量）は平均のみです。"
  },
  {
    "objectID": "chapter02.html#平均値とは",
    "href": "chapter02.html#平均値とは",
    "title": "\n2  平均値とはやじろべえの視点である\n",
    "section": "\n2.2 平均値とは",
    "text": "2.2 平均値とは\n　本講の平均値とは算術平均を意味しています。身長データ（\\(x\\)）の平均値は157.575です。"
  },
  {
    "objectID": "chapter02.html#度数分布表での平均値",
    "href": "chapter02.html#度数分布表での平均値",
    "title": "\n2  平均値とはやじろべえの視点である\n",
    "section": "\n2.3 度数分布表での平均値",
    "text": "2.3 度数分布表での平均値\n\n第1講での度数分布表df %>% \n  dplyr::select(`階級` = class, `度数` = n, `階級値` = mids,\n                `階級幅` = range, `累積度数` = cumsum_n,\n                `相対度数` = prop, `累積相対度数` = cumsum_prop) %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n　（算術）平均は全ての観測値の総和を総データ数で除したものですので、観測値を各階級の代表値である階級値で近似すると下式が成り立つことが分かります。\n\\[\\mbox{平均} = \\frac{\\sum{\\mbox{観測値}_i}}{総データ数} = \\frac{\\sum{\\mbox{観測値}_i}}{\\sum{度数}_i}\\]\n\\[ \\fallingdotseq \\frac{\\sum{(\\mbox{階級値}_i \\times \\mbox{度数}_i)}}{\\sum{度数}_i} = \\sum{(\\mbox{階級値}_i \\times \\mbox{相対度数}_i)}\\]\n　なぜなら \\[\\frac{\\mbox{度数}_i}{\\sum{\\mbox{度数}_i}} = \\mbox{相対度数}_i\\]\n\\[i = 1, 2, ... , n\\]\n\nP26 図表2−1 階級数×相対度数df %>% \n  dplyr::select(A = mids, B = prop) %>% \n  dplyr::mutate(`A x B` = A * B) %>% \n  dplyr::rename(`A 階級値` = A, `B 相対度数` = B,\n                `A x B` = `A x B`) %>% \n  df_print()\n\n\n\n  \n\n\n\n\nP26 図表2−1 平均値df %>% \n  dplyr::select(A = mids, B = prop) %>% \n  dplyr::mutate(`A x B` = A * B) %>% \n  dplyr::summarise(`平均値` = sum(`A x B`)) %>% \n df_print()\n\n\n\n  \n\n\n\n　\n　実データで求めた平均値は157.575ですので、階級値から求めた平均値との差は-0.175となり、度数分布表を作ることは平均値に大きな影響を与えていないことが分かります。"
  },
  {
    "objectID": "chapter02.html#平均値のヒストグラムの中での役割",
    "href": "chapter02.html#平均値のヒストグラムの中での役割",
    "title": "\n2  平均値とはやじろべえの視点である\n",
    "section": "\n2.4 平均値のヒストグラムの中での役割",
    "text": "2.4 平均値のヒストグラムの中での役割\n　階級値から求めた平均値をヒストグラム上にプロットすると下図のようになります。\n\nヒストグラムにおける平均値with(x, hist(height))\nabline(v = 157.75, lty = 2)"
  },
  {
    "objectID": "chapter02.html#平均値をどう捉えるべきか",
    "href": "chapter02.html#平均値をどう捉えるべきか",
    "title": "\n2  平均値とはやじろべえの視点である\n",
    "section": "\n2.5 平均値をどう捉えるべきか",
    "text": "2.5 平均値をどう捉えるべきか\n　平均値の捉え方は様々考えられますが、テキストでは下記のようにまとめています。\n\n全データ（値）を代表する値（点）\nデータは平均値の周辺に分布する\n数多く現れるデータは平均値への影響が大きい\nデータの分布が対象の場合、平均値は対象軸"
  },
  {
    "objectID": "chapter02.html#練習問題",
    "href": "chapter02.html#練習問題",
    "title": "\n2  平均値とはやじろべえの視点である\n",
    "section": "\n2.6 練習問題",
    "text": "2.6 練習問題\n\n2.6.1 解答例\n\n相対度数と階級値×相対度数を求めるdata.frame(mids = c(30, 50, 70, 90, 110, 130),\n           n = c(5, 10, 15, 40, 20, 10)) %>% \n  dplyr::mutate(prop = prop.table(n), cm = mids * prop) %>% \n  dplyr::rename(`階級値` = mids, `度数` = n, `相対度数` = prop,\n                `階級値×相対度数` = cm) %>% \n  df_print()\n\n\n\n  \n\n\n\n\n平均値（階級数×相対度数の和）を求めるdata.frame(mids = c(30, 50, 70, 90, 110, 130),\n           n = c(5, 10, 15, 40, 20, 10)) %>% \n  dplyr::mutate(prop = prop.table(n), cm = mids * prop) %>% \n  dplyr::summarise(`平均値` = sum(cm)) %>% \n  df_print()"
  },
  {
    "objectID": "chapter02.html#コラム平均値のとり方は１つではない",
    "href": "chapter02.html#コラム平均値のとり方は１つではない",
    "title": "\n2  平均値とはやじろべえの視点である\n",
    "section": "【コラム】平均値のとり方は、１つではない",
    "text": "【コラム】平均値のとり方は、１つではない\n算術平均（Arithmetic Mean）\n\\[\\frac{\\sum_{i=1}^n{x_i}}{n}\\]\n\n計算式通りの求め方sum(c(10, 90)) / length(c(10, 90))\n\n[1] 50\n\n\n\n標準で組み込まれている関数mean(c(10, 90))\n\n[1] 50\n\n\n　\n幾何平均（Geometric Mean）または相乗平均\n\\[\\sqrt{\\prod_{i=1}^n{x_i}}\\]\n\n幾何平均はフローしやすいので専用関数でpsych::geometric.mean(c(10, 90))\n\n[1] 30\n\n\n　\n二乗平均（Root Mean Square）\n\\[\\sqrt{\\frac{\\sum_{i=1}^n{x_i^2}}{n}}\\]\n\n計算式通りの求め方sqrt(mean(c(10, 90) ^ 2))\n\n[1] 64.03124\n\n\n　\n　seewaveパッケージで二乗平均が関数として定義されていますが、コードの中身は上記のsqrt(mean(x ^ 2))と同一です。\n\nフロー対策などは施されていませんseewave::rms(c(10, 90))\n\n[1] 64.03124\n\n\n　\n調和平均（Harmonic Mean）\n\\[\\frac{n}{\\sum_{i=1}^n{\\frac{1}{x_i}}}\\]\n\nパッケージで提供されていますpsych::harmonic.mean(c(10, 90))\n\n[1] 18\n\n\n　\nトリム平均\n　トリム平均は体操競技の評点などで使われる平均値の計算方法で、値を小さい方から順に並べ、上位側と下位側から一定の割合で値を除き算術平均を求めます。外れ値や異常値などを影響を排除するために使われることが多いです。\n\n知っておくと便利なトリム平均mean(c(0, 1:8, 30))\n\n[1] 6.6\n\n知っておくと便利なトリム平均mean(c(0, 1:8, 30), trim = 0.25)  # データの両側2.5%を対象外とする\n\n[1] 4.5"
  },
  {
    "objectID": "chapter02.html#追加問題",
    "href": "chapter02.html#追加問題",
    "title": "\n2  平均値とはやじろべえの視点である\n",
    "section": "追加問題",
    "text": "追加問題\n　身長のデータを用いて階級幅が変わると度数分布表から求める平均値がどのように変化するか確認してみましょう。\n階級幅が倍になった場合\n\n階級幅が倍になった場合の平均値の差x %>% \n  dplyr::mutate(class = cut(height,\n                            breaks = c(140, 150, 160, 170),\n                            include.lowest = FALSE, right = TRUE)) %>% \n  dplyr::count(class) %>% \n  dplyr::mutate(class_value = as.character(class)) %>% \n  tidyr::separate(class_value, into = c(\"l\", \"h\"), sep = \",\") %>% \n  dplyr::mutate(l = as.numeric(stringr::str_remove(l, \"[[:punct:]]\")),\n                h = as.numeric(stringr::str_remove(h, \"[[:punct:]]\"))) %>% \n  dplyr::mutate(mids = ((l + 1) + h) / 2) %>% \n  dplyr::mutate(range = h - l, cumsum_n = cumsum(n),\n                prop = prop.table(n), cumsum_prop = cumsum(prop)) %>% \n  dplyr::select(A = mids, B = prop) %>% \n  dplyr::mutate(`A x B` = A * B) %>% \n  dplyr::summarise(`階級値による平均値` = sum(`A x B`)) %>% \n  dplyr::mutate(`算術平均` = mean(x$height),\n                `差` = `算術平均` - `階級値による平均値`) %>% \n  df_print()\n\n\n\n  \n\n\n\n階級幅が半分になった場合\n\n階級幅が半分になった場合の平均値の差x %>% \n  dplyr::mutate(class = cut(height,\n                            breaks = seq(from = 140, to = 170, by = 2.5),\n                            include.lowest = FALSE, right = TRUE)) %>% \n  dplyr::count(class) %>% \n  dplyr::mutate(class_value = as.character(class)) %>% \n  tidyr::separate(class_value, into = c(\"l\", \"h\"), sep = \",\") %>% \n  dplyr::mutate(l = as.numeric(stringr::str_remove(l, \"[[:punct:]]\")),\n                h = as.numeric(stringr::str_remove(h, \"[[:punct:]]\"))) %>% \n  dplyr::mutate(mids = ((l + 1) + h) / 2) %>% \n  dplyr::mutate(range = h - l, cumsum_n = cumsum(n),\n                prop = prop.table(n), cumsum_prop = cumsum(prop)) %>% \n  dplyr::select(A = mids, B = prop) %>% \n  dplyr::mutate(`A x B` = A * B) %>% \n  dplyr::summarise(`階級値による平均値` = sum(`A x B`)) %>% \n  dplyr::mutate(`算術平均` = mean(x$height),\n                `差` = `算術平均` - `階級値による平均値`) %>% \n  df_print()"
  },
  {
    "objectID": "chapter03.html#データの散らばりやバラツキを知りたい",
    "href": "chapter03.html#データの散らばりやバラツキを知りたい",
    "title": "\n3  データの散らばり具合を見積もる統計量\n",
    "section": "\n3.1 データの散らばりやバラツキを知りたい",
    "text": "3.1 データの散らばりやバラツキを知りたい\n　第2講で学んだ平均値（算術平均）は、データを代表する統計量で、ある一点（支点・重心）を示しているに過ぎません。データが平均値の周辺にどのように分布しているかはヒストグラムを使うことで視覚的には確認できますが、統計量として数値的に扱えた方がなにかと便利なはずです。"
  },
  {
    "objectID": "chapter03.html#バスの到着時刻の例で分散を理解する",
    "href": "chapter03.html#バスの到着時刻の例で分散を理解する",
    "title": "\n3  データの散らばり具合を見積もる統計量\n",
    "section": "\n3.2 バスの到着時刻の例で分散を理解する",
    "text": "3.2 バスの到着時刻の例で分散を理解する\n　蛇足ですが実際の路線バスでは予定時刻より早く到着しないように調整運転がなされていますので、時刻より大幅に早着することは稀です。\n\nベクトルを読み込みたい場合はscan()関数を使いますx <- scan(file = \"./data/P36_図表3-1.csv\", sep = \",\")\n\nx\n\n[1] 32 27 29 34 33\n\n\n　平均値を求めるmean()関数がありますが、ここでは平均値の計算式通りの計算を行っています。\n\n平均値を求める平均値 <- sum(x) / length(x)\n平均値\n\n[1] 31\n\n\n\n偏差を求める偏差 = x - 平均値\n偏差\n\n[1]  1 -4 -2  3  2\n\n\n　偏差の総和は必ずゼロ（\\(0\\)）になります。\n\n偏差の総和を求めるsum(偏差)\n\n[1] 0\n\n\n　偏差の二乗和をデータの個数で割ったものは、（標本）分散と呼ばれます。不偏分散と呼ばれる分散は計算式が異なります。Rで分散を計算するvar()関数は不偏分散を求める関数です。\n\n（標本）分散を求めるsum(偏差 ^ 2) / length(x)\n\n[1] 6.8\n\n\n\n\nvar()関数は不偏分散var(x)\n\n[1] 8.5\n\n　偏差の二乗平均値（\\(= \\sqrt{\\mbox{分散}}\\)）は標準偏差と呼ばれます。Rで標準偏差を計算するsd()関数は不偏分散のルートを取ったものです。\n\n（標本）標準偏差を求めるsqrt(sum(偏差 ^ 2) / length(x))\n\n[1] 2.607681\n\n\n\n\nsd()関数は不偏標準偏差sd(x)\n\n[1] 2.915476"
  },
  {
    "objectID": "chapter03.html#標準偏差の意味",
    "href": "chapter03.html#標準偏差の意味",
    "title": "\n3  データの散らばり具合を見積もる統計量\n",
    "section": "\n3.3 標準偏差の意味",
    "text": "3.3 標準偏差の意味\n\n対象データx <- read.csv(file = \"./data/P39_図表3-4.csv\") \n\nx %>% \n  df_print()\n\n\n\n  \n\n\n\n\n各々の平均値を求めるmean <- x %>% \n  dplyr::summarise(X平均値 = mean(X), Y平均値 = mean(Y))\n\nmean %>% \n  df_print()\n\n\n\n  \n\n\n\n\n各々の偏差を求めるx %>% \n  dplyr::mutate(X偏差 = X - mean$X平均値,\n                Y偏差 = Y - mean$Y平均値) %>% \n  df_print()\n\n\n\n  \n\n\n\n\n各々の標準偏差を求めるx %>% \n  dplyr::mutate(X偏差 = X - mean$X平均値,\n                Y偏差 = Y - mean$Y平均値) %>% \n  dplyr::summarise(X標準偏差 = sqrt(sum(X偏差 ^ 2) / length(X)),\n                   Y標準偏差 = sqrt(sum(Y偏差 ^ 2) / length(Y))) %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n　偏差と標準偏差を可視化すると下図のようになり、XよりYの方が広範囲に分布していることが分かります。\n\n偏差と標準偏差を可視化するx %>% \n  dplyr::mutate(X偏差 = X - mean$X平均値,\n                Y偏差 = Y - mean$Y平均値) %>% \n  dplyr::select(-X, -Y) %>% \n  stripchart(xlim = c(-5, 5))\nabline(v = c(-0.89, 0.89), lty = 3)  # X標準偏差／ドット（点線）\nabline(v = c(-3.03, 3.03), lty = 2)  # Y標準偏差／ダッシュ（鎖線）"
  },
  {
    "objectID": "chapter03.html#度数分布表から標準偏差を求める",
    "href": "chapter03.html#度数分布表から標準偏差を求める",
    "title": "\n3  データの散らばり具合を見積もる統計量\n",
    "section": "\n3.4 度数分布表から標準偏差を求める",
    "text": "3.4 度数分布表から標準偏差を求める\n\n対象データx <- read.csv(file = \"./data/P40_図表3-6.csv\",\n              fileEncoding = \"UTF-8\")\n\nx %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n　第2講の「2−3 度数分布表での平均値」で学んだように度数分布表から平均値（の近似値）は \\[\\mbox{平均値} \\fallingdotseq \\sum{(\\mbox{階級値} \\times \\mbox{相対度数})}\\] 　で求めることができます。\n\n度数分布表から平均値を求めるx %>% \n  dplyr::mutate(AxB = A階級値 * B相対度数) %>% \n  df_print()\n\n\n\n  \n\n\n\n\n度数分布表から平均値を求める平均値 <- x %>% \n  dplyr::mutate(AxB = A階級値 * B相対度数) %>% \n  dplyr::summarize(平均値 = sum(AxB)) %>% \n  dplyr::pull(平均値)\n平均値\n\n[1] 2\n\n\n　\n　平均値を求められたので \\[\\mbox{階級の偏差（C階級値-平均値）} = \\mbox{階級値} - \\mbox{平均値}\\] 　とすると度数分布表の計算値と同じ考え方を適用し \\[\\mbox{階級の偏差の二乗平均} = \\sum{(\\mbox{階級の偏差}^2 \\times \\mbox{相対度数})} = \\mbox{分散}\\] 　となります。\n\n度数分布表から分散と階級偏差を求めるx %>% \n  dplyr::mutate(C = A階級値 - 平均値) %>% \n  dplyr::mutate(`C^2` = C ^ 2) %>% \n  dplyr::mutate(`C^2xB` = `C^2` * B相対度数) %>% \n  dplyr::select(A階級値, `C階級値-平均値` = C,\n                `C^2`, B相対度数, `C^2xB`) %>% \n  df_print()\n\n\n\n  \n\n\n\n\n度数分布表から分散と階級偏差を求めるx %>% \n  dplyr::mutate(`C` = `A階級値` - `平均値`) %>% \n  dplyr::mutate(`C^2` = `C` ^ 2) %>% \n  dplyr::mutate(`C^2xB` = `C^2` * `B相対度数`) %>% \n  dplyr::select(`A階級値`, `C階級値-平均値` = `C`,\n                `C^2`, `B相対度数`, `C^2xB`) %>% \n  dplyr::summarise(`分散` = sum(`C^2xB`)) %>% \n  dplyr::mutate(`標準偏差` = sqrt(`分散`)) %>% \n  df_print()"
  },
  {
    "objectID": "chapter03.html#練習問題",
    "href": "chapter03.html#練習問題",
    "title": "\n3  データの散らばり具合を見積もる統計量\n",
    "section": "練習問題",
    "text": "練習問題\n　次の架空のデータの標準偏差を次のステップで計算してみよ。ステップの記載は省略します。\n\n対象データデータ <- scan(file = \"./data/P42_練習問題_v.csv\", sep = \",\")\n\nデータ\n\n [1] 6 4 6 6 6 3 7 2 2 8\n\n\n解答例\n\n平均値を求める平均値 <- sum(データ) / length(データ)\n平均値\n\n[1] 5\n\n\n\n偏差を求める偏差 <- データ - 平均値\n偏差\n\n [1]  1 -1  1  1  1 -2  2 -3 -3  3\n\n\n\n二乗偏差を求める二乗偏差 <- 偏差 ^ 2\n二乗偏差\n\n [1] 1 1 1 1 1 4 4 9 9 9\n\n\n\n分散を求める分散 <- sum(二乗偏差) / length(二乗偏差)\n分散\n\n[1] 4\n\n\n\n標準偏差を求める標準偏差 <- sqrt(分散)\n標準偏差\n\n[1] 2"
  },
  {
    "objectID": "chapter03.html#追加問題",
    "href": "chapter03.html#追加問題",
    "title": "\n3  データの散らばり具合を見積もる統計量\n",
    "section": "追加問題",
    "text": "追加問題\n　P16にある身長データの度数分布表を作り、分散と標準偏差を求めてみましょう。\n\n\n\n\n  \n\n\n\n　\n解答例\n度数分布表から平均・分散・標準偏差を求める\n\n度数分布表から平均値を求めるx %>% \n  dplyr::mutate(AxB = A階級値 * B相対度数) %>% \n  df_print()\n\n\n\n  \n\n\n度数分布表から平均値を求める平均値 <- x %>% \n  dplyr::mutate(AxB = A階級値 * B相対度数) %>% \n  dplyr::summarise(平均値 = sum(AxB)) %>% \n  dplyr::pull(平均値)\n平均値\n\n[1] 157.75\n\n\n\n度数分布表から分散と標準偏差を求めるx %>% \n  dplyr::mutate(C = A階級値 - 平均値) %>% \n  dplyr::mutate(`C^2` = C ^ 2) %>% \n  dplyr::mutate(`C^2xB` = `C^2` * B相対度数) %>% \n  df_print()\n\n\n\n  \n\n\n\n\n度数分布表から分散と標準偏差を求めるfreq_summary <- x %>% \n  dplyr::mutate(C = A階級値 - 平均値) %>% \n  dplyr::mutate(`C^2` = C ^ 2) %>% \n  dplyr::mutate(`C^2xB` = `C^2` * B相対度数) %>% \n  dplyr::summarise(平均 = sum(A階級値 * B相対度数),\n                   分散 = sum(`C^2xB`)) %>% \n  dplyr::mutate(標準偏差 = sqrt(分散))\n\nfreq_summary %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n生データから平均・分散・標準偏差を求める\n\n生データから平均・分散・標準偏差を求める\"./data/P16_図表1-1 .csv\" %>% \n  readr::read_csv(col_names = FALSE,\n                  show_col_types = FALSE) %>% \n  tidyr::pivot_longer(cols = dplyr::starts_with(\"X\"),\n                      names_to = \"name\",\n                      values_to = \"value\") %>% \n  dplyr::arrange(name) %>% \n  dplyr::select(height = value) %>% \n  dplyr::mutate(偏差 = height - mean(height)) %>% \n  dplyr::mutate(二乗偏差 = 偏差 ^ 2) %>% \n  df_print()\n\n\n\n  \n\n\n\n\n生データから平均・分散・標準偏差を求めるraw_summary <- \"./data/P16_図表1-1 .csv\" %>% \n  readr::read_csv(col_names = FALSE,\n                  show_col_types = FALSE) %>% \n  tidyr::pivot_longer(cols = dplyr::starts_with(\"X\"),\n                      names_to = \"name\",\n                      values_to = \"value\") %>% \n  dplyr::arrange(name) %>% \n  dplyr::select(height = value) %>% \n  dplyr::mutate(偏差 = height - mean(height)) %>% \n  dplyr::mutate(二乗偏差 = 偏差 ^ 2) %>% \n  dplyr::summarise(平均 = sum(height) / length(height),\n                   分散 = sum(二乗偏差) / length(height),\n                   標準偏差 = sqrt(分散))\n\nraw_summary %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n度数分布表と生データの平均・分散・標準偏差を比較する\n\n度数分布表からの要約統計量freq_summary %>% \n  df_print()\n\n\n\n  \n\n\n\n\n生データからの要約統計量raw_summary %>% \n  df_print()\n\n\n\n  \n\n\n\n\n度数分布表と生データの差(freq_summary - raw_summary) %>% \n  df_print()"
  },
  {
    "objectID": "chapter04.html#標準偏差は波の激しさ",
    "href": "chapter04.html#標準偏差は波の激しさ",
    "title": "\n4  そのデータは「月並み」か「特殊」か？ 標準偏差で評価する\n",
    "section": "\n4.1 標準偏差は波の「激しさ」",
    "text": "4.1 標準偏差は波の「激しさ」\n　標準偏差は平均値からどの程度データがばらついているかを表しています。テキストではこのばらつきを「波打ちの激しさ」と表現しています。"
  },
  {
    "objectID": "chapter04.html#標準偏差がわかるとデータの特殊性を評価できる",
    "href": "chapter04.html#標準偏差がわかるとデータの特殊性を評価できる",
    "title": "\n4  そのデータは「月並み」か「特殊」か？ 標準偏差で評価する\n",
    "section": "\n4.2 標準偏差がわかるとデータの特殊性を評価できる",
    "text": "4.2 標準偏差がわかるとデータの特殊性を評価できる\n　標準偏差がわかるということは、以下がわかるということになります。\n\n一つのデータ（セット）の中にある任意の値の持つ意味\n複数のデータ（セット）の違い"
  },
  {
    "objectID": "chapter04.html#複数のデータセットの比較",
    "href": "chapter04.html#複数のデータセットの比較",
    "title": "\n4  そのデータは「月並み」か「特殊」か？ 標準偏差で評価する\n",
    "section": "\n4.3 複数のデータセットの比較",
    "text": "4.3 複数のデータセットの比較\n　（省略）"
  },
  {
    "objectID": "chapter04.html#加工されたデータの平均値と標準偏差",
    "href": "chapter04.html#加工されたデータの平均値と標準偏差",
    "title": "\n4  そのデータは「月並み」か「特殊」か？ 標準偏差で評価する\n",
    "section": "\n4.4 加工されたデータの平均値と標準偏差",
    "text": "4.4 加工されたデータの平均値と標準偏差\n　以下のデータに一定の加工を加えた際に平均値や標準偏差がどのように変化するかを見てみましょう。\n\n対象データx <- read.csv(file = \"./data/P49_図表4-5.csv\")\n\nx %>% \n  df_print()\n\n\n\n  \n\n\n\n　\nデータに一定数を加えた場合\n　それぞれに\\(4\\)を加える。\n\n元データ全てに\\(4\\)を加えるx %>% \n  dplyr::mutate(Y = X + 4) %>% \n  df_print()\n\n\n\n  \n\n\n\n\nそれぞれの平均値を求めるmean <- x %>% \n  dplyr::mutate(Y = X + 4) %>% \n  dplyr::summarise(X = mean(X), Y = mean(Y))\n\nmean %>% \n  df_print()\n\n\n\n  \n\n\n\n\n求めた平均値を用いてそれぞれの偏差を求めるdev <- x %>% \n  dplyr::mutate(Y = X + 4) %>% \n  dplyr::mutate(X = X - mean$X, Y = Y - mean$Y)\n\ndev %>% \n  df_print()\n\n\n\n  \n\n\n\n\n求めた偏差を用いてそれぞれの分散を求めるvar <- dev %>% \n  dplyr::summarize(X = sum(X ^ 2) / length(X),\n                   Y = sum(Y ^ 2) / length(Y))\n\nvar %>% \n  df_print()\n\n\n\n  \n\n\n\n\n求めた分散を用いてそれぞれの標準偏差を求めるsqrt(var) %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n　以上のようにデータに一定数を加えると平均値は加えた一定値の分だけ大きくなりますが、他の統計量は変化していないことが分かります。元データが正規分布のデータであると仮定して可視化すると下図のようになります。\n\n元データ（点線：左）と加算データ（破線：右）curve(dnorm(x, mean = 4, sd = 2), -3, 15, lty = 3, xlab = \"\", ylab = \"\")\nabline(v = 4, lty = 3)\ncurve(dnorm(x, mean = 8, sd = 2), -3, 15, add = TRUE, lty = 2, xlab = \"\", ylab = \"\")\nabline(v = 8, lty = 2)\n\n\n\n\n　\nデータに一定数を乗じた場合\n　それぞれに\\(2\\)を乗ずる。\n\n元データ全てに\\(2\\)を乗ずるx %>% \n  dplyr::mutate(Y = X * 2) %>% \n  df_print()\n\n\n\n  \n\n\n\n\nそれぞれの平均値を求めるmean <- x %>% \n  dplyr::mutate(Y = X * 2) %>% \n  dplyr::summarise(X = mean(X), Y = mean(Y))\n\nmean %>% \n  df_print()\n\n\n\n  \n\n\n\n\n求めた平均値を用いてそれぞれの偏差を求めるdev <- x %>% \n  dplyr::mutate(Y = X * 2) %>% \n  dplyr::mutate(X = X - mean$X, Y = Y - mean$Y)\n\ndev %>% \n  df_print()\n\n\n\n  \n\n\n\n\n求めた偏差を用いてそれぞれの分散を求めるvar <- dev %>% \n  dplyr::summarize(X = sum(X ^ 2) / length(X),\n                   Y = sum(Y ^ 2) / length(Y))\n\nvar %>% \n  df_print()\n\n\n\n  \n\n\n\n\n求めた分散を用いてそれぞれの標準偏差を求めるsqrt(var) %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n　以上のようにデータに一定数を乗じると平均値は乗じた一定値の分だけ大きくなり、他の統計量も乗じた一定値の分だけ大きくなっていることが分かります。元データが正規分布のデータであると仮定して可視化すると下図のようになります。\n\n元データ（点線：左）と加算データ（破線：右）curve(dnorm(x, mean = 4, sd = 2), -3, 15, lty = 3, xlab = \"\", ylab = \"\")\nabline(v = 4, lty = 3)\ncurve(dnorm(x, mean = 8, sd = 4), -3, 15, add = TRUE, lty = 2, xlab = \"\", ylab = \"\")\nabline(v = 8, lty = 2)\n\n\n\n\n　\n　整理すると下表になります。\n\n\n\n\n\n\n\n\n加工方法\n平均値\n標準偏差\n備考\n\n\n\n無加工（元データ\\(x\\)）\n\\(\\bar{x}\\)\n\\(SD\\)\n\n\n\n定数の加算(\\(x + k\\))\n\\(\\bar{x} + k\\)\n\\(SD\\)\n変化するのは平均値のみ\n\n\n定数の乗算(\\(x \\times k\\))\n\\(\\bar{x} \\times k\\)\n\\(SD \\times k\\)\n平均値・標準偏差ともに変化\n\n\n\n\\(k\\): 任意の実数\n　\n標準偏差何個分となるようにデータを加工する効果\n　ここで説明されているのは「正規化」です。\n\n対象データ（P49のデータX）x <- read.csv(file = \"./data/P49_図表4-5.csv\")\n\nx %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n　上記のP49のデータは、平均値\\(4\\)、標準偏差\\(2\\)ですので、\\((データ - 平均値) \\div 標準偏差\\)を計算（正規化）すると下記のようになります。\n\n正規化するx %>% \n  dplyr::mutate(dev = (X - (sum(X) / length(X))),\n                nX = dev / sqrt(sum(dev ^ 2) / length(dev))) %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n　nXの平均値と標準偏差は以下のように\\(0\\)と\\(1\\)になることが分かります。\n\n正規化したデータの平均と標準偏差を求めるx %>% \n  dplyr::mutate(nX = (X - 4) / 2) %>% \n  dplyr::summarise(mean = sum(nX) / length(nX),\n                   sd = sqrt(sum((nX - mean) ^ 2) / length(nX))) %>% \n  df_print()"
  },
  {
    "objectID": "chapter04.html#練習問題",
    "href": "chapter04.html#練習問題",
    "title": "\n4  そのデータは「月並み」か「特殊」か？ 標準偏差で評価する\n",
    "section": "練習問題",
    "text": "練習問題\n　（省略）"
  },
  {
    "objectID": "chapter04.html#コラム偏差値で嫌な思いをしたことのあるあなたに",
    "href": "chapter04.html#コラム偏差値で嫌な思いをしたことのあるあなたに",
    "title": "\n4  そのデータは「月並み」か「特殊」か？ 標準偏差で評価する\n",
    "section": "【コラム】偏差値で嫌な思いをしたことのあるあなたに",
    "text": "【コラム】偏差値で嫌な思いをしたことのあるあなたに\n　（省略）"
  },
  {
    "objectID": "chapter04.html#追加問題",
    "href": "chapter04.html#追加問題",
    "title": "\n4  そのデータは「月並み」か「特殊」か？ 標準偏差で評価する\n",
    "section": "追加問題",
    "text": "追加問題\n　P16の身長データを正規化（\\((\\mbox{データ} - \\mbox{平均値}) \\div \\mbox{標準偏差}\\)）してみましょう。\n　\n解答例\n\nscale()関数を使うと簡単に正規化できますx <- \"./data/P16_図表1-1 .csv\" %>% \n  readr::read_csv(col_names = FALSE, show_col_types = FALSE) %>% \n  tidyr::pivot_longer(cols = dplyr::starts_with(\"X\"),\n                      names_to = \"name\", values_to = \"value\") %>% \n  dplyr::arrange(name) %>% \n  dplyr::select(height = value) %>% \n  dplyr::mutate(normalized = scale(height))\n\nx %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n　正規化前後の平均値と標準偏差を比べると下記のようになります。\n\n正規化前の平均値と標準偏差x %>% \n  dplyr::summarise(mean = sum(height) / length(height),\n                   sd = sqrt(sum((height - mean)^ 2) / length(height))) %>% \n  df_print()\n\n\n\n  \n\n\n\n\n正規化後の平均値と標準偏差x %>% \n  dplyr::summarise(mean = sum(normalized) / length(normalized),\n                   sd = sqrt(sum((normalized - mean)^ 2) / length(normalized))) %>% \n  df_print()"
  },
  {
    "objectID": "chapter05.html#株の平均収益率とは何か",
    "href": "chapter05.html#株の平均収益率とは何か",
    "title": "\n5  標準偏差は株のリスクの指標として活用できる\n",
    "section": "\n5.1 株の平均収益率とは何か？",
    "text": "5.1 株の平均収益率とは何か？\n　株価の変動を利用して得られる収益は「キャピタルゲイン」と呼ばれます。キャピタルゲインを目当てとした株取引で重要になる指標のひとつに「収益率」があります。毎月の終値が前月の終値に対して、値上がった、または、値下がった率を「月次収益率」といいます。「月次平均収益率」は、月次収益率の一年間（十二ヶ月）単位で平均した値になります。\n　\n　実際に株探というサイトから某社の月次株価一覧を取得して月次平均収益率を計算してみましょう。\n\nサイトから株価データを取得するlibrary(tidyverse)\nlibrary(rvest)\n\nsite_url <- \"https://kabutan.jp/stock/kabuka?code=7203&ashi=mon&page=\"\npages <- c(1:5)\nxpath <- '//*[@id=\"stock_kabuka_table\"]/table[2]'\n\nstock <- purrr::map2(site_url, pages, ~ paste0(.x, .y)) %>%\n  purrr::map2_df(pages, .f = function(.x, .y) {\n    xml2::read_html(.x) %>% \n      rvest::html_element(xpath = xpath) %>%\n      rvest::html_table(header = FALSE) %>%\n      dplyr::slice(-1)\n  }\n)\n\nstock %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n　上表の「X7」が月次収益率、月次収益率の十二ヶ月平均が月次平均収益率になりますので、データがそろっている年の月次平均収益率を算出してみます。\n\n月次平均収益率を求めるstock %>% \n  dplyr::mutate(日付 = lubridate::as_date(X1),\n                年 = lubridate::year(日付)) %>% \n  dplyr::filter(年 >= 2010 & 年 <= 2021) %>% \n  dplyr::group_by(年) %>% \n  dplyr::summarise(月次平均収益率 = mean(as.numeric(X7)) %>% \n                            round(digits = 2)) %>% \n  df_print()"
  },
  {
    "objectID": "chapter05.html#平均収益率だけでは優良な投資かどうかは判断できない",
    "href": "chapter05.html#平均収益率だけでは優良な投資かどうかは判断できない",
    "title": "\n5  標準偏差は株のリスクの指標として活用できる\n",
    "section": "\n5.2 平均収益率だけでは、優良な投資かどうかは判断できない",
    "text": "5.2 平均収益率だけでは、優良な投資かどうかは判断できない\n\nCode\"./data/P56_ 図表5-3.csv\" %>% \n  read.csv() %>% \n  df_print()\n\n\n\n  \n\n\n\n\n月次平均収益率を求める\"./data/P56_ 図表5-3.csv\" %>% \n  read.csv() %>% \n  dplyr::summarise_if(is.numeric, mean) %>% \n  round(digits = 2) %>% \n  df_print()\n\n\n\n  \n\n\n\n\n月次平均収益率の標準偏差を求めるSD <- function(x) {\n  sqrt((length(x) - 1) / length(x)) * sd(x)\n}\n\n\"./data/P56_ 図表5-3.csv\" %>% \n  read.csv() %>% \n  dplyr::summarise_if(is.numeric, SD) %>% \n  round(digits = 2) %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n　前節の株探のデータを利用して月次平均収益率と標準偏差を求めます。\n\n実際の株価から月次平均収益率と標準偏差を求めるstock %>% \n  dplyr::mutate(日付 = lubridate::as_date(X1), 年 = lubridate::year(日付),\n                月次収益率 = as.numeric(X7)) %>% \n  dplyr::filter(年 >= 2010 & 年 <= 2021) %>% \n  dplyr::group_by(年) %>% \n  dplyr::summarise(月次平均収益率 = mean(月次収益率) %>% round(digits = 2),\n                   標準偏差 = SD(月次収益率) %>% round(digits = 2)) %>% \n  dplyr::mutate(下 = 月次平均収益率 - 標準偏差, 上 = 月次平均収益率 + 標準偏差) %>% \n  df_print()"
  },
  {
    "objectID": "chapter05.html#ボラリティが意味するところ",
    "href": "chapter05.html#ボラリティが意味するところ",
    "title": "\n5  標準偏差は株のリスクの指標として活用できる\n",
    "section": "\n5.3 ボラリティが意味するところ",
    "text": "5.3 ボラリティが意味するところ\n\n実際の株価から直近三年の月次収益率の変動を可視化するstock %>% \n  dplyr::mutate(日付 = lubridate::as_date(X1), 月次収益率 = as.numeric(X7),\n                年 = lubridate::year(日付), 月 = lubridate::month(日付)) %>% \n  dplyr::filter(年 >= 2019 & 年 <= 2021) %>% \n  dplyr::mutate(年 = as.factor(年)) %>% \n  ggplot2::ggplot(ggplot2::aes(x = 月, y = 月次収益率, fill = 年)) +\n    ggplot2::geom_bar(stat = \"identity\", position = \"dodge\")"
  },
  {
    "objectID": "chapter05.html#練習問題",
    "href": "chapter05.html#練習問題",
    "title": "\n5  標準偏差は株のリスクの指標として活用できる\n",
    "section": "練習問題",
    "text": "練習問題"
  }
]