[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Rで学ぶ『完全独習 統計学入門』",
    "section": "",
    "text": "本資料は『完全独習 統計学入門』小島寛之著（以降、テキスト）の内容をRで計算する方法を紹介しています1。テキストに記載されているデータの一部をCSVファイルに起こして利用していますが、データ自体の著作権は原著作者にあります。また、CSVファイルは著作権を侵害する意図で作成したものではありません。1 Rのインストール方法や基本文法などには触れません\n　\n\n　本書の想定読者は以下に該当する方です。\n\nRに関する基本的な知識を有している方\n\nデータフレーム型や因子型などの変数型の知識\n変数の代入・参照方法\n\ntidyverseの基本的な知識（パイプ演算子など）\n\n\nRで統計量を求めてみたい方\n\n　\n\n\n\n\n\n\ndf_print()関数について\n\n\n\n　本書のコードに出てくるdf_pirnt()関数はデータフレームを出力フォーマットごとに適切な形式で出力するために定義した関数です。RやCRANのパッケージで提供されている関数ではありません。ご自身の環境でコードを実行する際にはdf_print()関数とその直前のパイプ演算子（%>%）を削除してから実行してください。\n　例）x %>% df_printとなっている場合は%>% df_print()を削除しxを実行してください。\n\n\n　\n\n\n\n\n\n\nTip: Index\n\n\n\n　左側に章単位のインデックス、右側に現在表示中のページ内のインデックスが表示されます。インデックスはウィンドウサイズなどにより表示位置が変わったり、自動的に縮小表示されたりします。\n\n\n\n\n\n\n\n\nTip: Code Block Operation\n\n\n\n　コードブロックの上にある▼マークをクリックするとコードの表示・非表示を切り替えることができます。また、コードブロック中のパッケージ名や関数名にマウスオーバーした際に下線が表示されるものは、クリックをすると説明ページ（英語）にジャンプできます。 　コードブロック右上にあるアイコンをクリックするとコードをクリップボードにコピーできます。"
  },
  {
    "objectID": "chapter00.html",
    "href": "chapter00.html",
    "title": "【序】なぜ、統計手法が必要か",
    "section": "",
    "text": "本講はテキストの概観に関する第一回講義における演習をRで解答したものです。テキストとは異なるデータを利用しており演習自体やデータの著作権は講義担当者にあります。"
  },
  {
    "objectID": "chapter00.html#グループ演習1分布の特徴を捉える",
    "href": "chapter00.html#グループ演習1分布の特徴を捉える",
    "title": "【序】なぜ、統計手法が必要か",
    "section": "グループ演習1（分布の特徴を捉える）",
    "text": "グループ演習1（分布の特徴を捉える）\n\n三教科の得点表x <- \"./data/Pre_P20_演習1.csv\" %>% \n  read.csv()\n\nx %>% df_print()\n\n\n\n  \n\n\n\n　\nQ1 各教科の得点の違いを考える（演習1）\n　データの分布傾向を見るには箱ひげ図が便利です。Rで箱ひげ図を描くにはboxplot()関数を用います。\n\n箱ひげ図による得点分布の可視化boxplot(x)\n\n\n\n\n　\n　箱ひげ図は五数要約の値を箱とひげ（whisker）で表現したもので、boxplot()関数の場合は外れ値（outliers）が描かれます。五数要約は下表のようなもので、上から最小値、第一四分位値（25%点）、中央値・第二四分位値（50%点）、第三四分位値（75%点）、最大値となっています。\n\n五数要約x %>% \n  dplyr::summarise(dplyr::across(.cols = dplyr::everything(),\n                                 .fns = fivenum)) %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n　箱ひげ図からは以下のような特徴がうかがえます。\n\n英語の得点は他の二教科に比べて狭い範囲に得点が集中している\n数学の得点は他の二教科に比べて全体的に得点が低めである\n国語の得点は中央値は英語の得点と同じである\n国語の得点は英語の得点より倍近い範囲に得点が散らばっている\nどの教科も一人は、理解度が高い（高得点な）人がいる\n\n　\n　箱ひげ図はデータを要約した結果を図示したものですので、もう少し細かい分布を見るにはヒストグラム（度数分布表）が便利です。Rではhist()関数を用いて描きます。\n\n各教科の得点分布（ヒストグラム）with(x, hist(国語))\n\n\n\n各教科の得点分布（ヒストグラム）with(x, hist(数学))\n\n\n\n各教科の得点分布（ヒストグラム）with(x, hist(英語))\n\n\n\n\n　\n　ヒストグラムで見ると以下のような特徴がうかがえます。\n\n概ね箱ひげ図でうかがえた特徴通りである\n国語の得点の7割近くが中央値の付近に集中している\n英語の得点の7割近くが中央値の付近に集中している\n英語で得点30点はありえない（このデータでは存在しない）\n数学の得点は他の二教科にくらべると綺麗な分布をしている\n\n　\n　教科間の得点の関係をみるには散布図行列が便利です。Rではpairs()関数が標準関数として用意されていますが、ここではpsychパッケージのpsych::pairs.panels(x)関数を用います。\n\n散布図行列psych::pairs.panels(x)\n\n\n\n\n　\n　散布図行列で見ると以下のような特徴がうかがえます。\n\n不自然なほど教科間に強い相関が認められる\n\n人為的な的なデータであることがうかがえる"
  },
  {
    "objectID": "chapter00.html#個人演習基本統計量の算出",
    "href": "chapter00.html#個人演習基本統計量の算出",
    "title": "【序】なぜ、統計手法が必要か",
    "section": "個人演習（基本統計量の算出）",
    "text": "個人演習（基本統計量の算出）\nQ2 基本統計量から違いを考察する（演習1）\n　グループ演習1のデータを用いて基本統計量を求めます。最初は平均値です。Rで平均値を求めるにはmean()関数を用います。\n\n平均値x %>% \n  dplyr::summarise(dplyr::across(dplyr::everything(), mean)) %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n　参考として中央値も求めてみます。中央値はmedian()関数で求めます。\n\n中央値x %>% \n  dplyr::summarise(dplyr::across(dplyr::everything(), median)) %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n　次に分散（母分散）を求めます。Rには母分散を求める関数がありませんので、本資料では計算式（\\(\\frac{\\sum{(x_i - \\mu)^2}}{n} = \\sigma^2\\)）をVAR()関数として定義しています。\n\n（母）分散x %>% \n  dplyr::summarise(dplyr::across(dplyr::everything(), VAR)) %>% \n  round(digits = 1) %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n　分散を求めましたので標準偏差（母標準偏差）を求めますが、母分散同様に求める関数がありませんので本資料では計算式（\\(\\sqrt{\\frac{\\sum{(x_i - \\mu)^2}}{n}} = \\sigma\\)）をSD()関数として定義しています。\n\n（母）標準偏差x %>% \n  dplyr::summarise(dplyr::across(dplyr::everything(), SD)) %>% \n  round(digits = 1) %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n　最後に変動係数（ばらつきを比較するための値）を求めます。\n\n変動係数x %>% \n  dplyr::summarise(dplyr::across(dplyr::everything(),\n                                 function(x = .) {SD(x)/mean(x)} )) %>% \n  round(digits = 2) %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n考察\n　以上の基本統計量より\n\n平均値から数学の得点は他の二教科に比べて全体的に得点が低めであることがわかる\n中央値から三教科とも左右対称な分布をしいていることが推測できる\n標準偏差から英語の得点が他の二教科に比べて狭い範囲に集中していることがわかる\n変動係数から数学より国語の方がバラツキが少ないことがわかる\n変動係数から国語より英語の方がバラツキが少ないことがわかる\n\nしたがって\n\n国語は他の二教科に比べて理解度にバラツキがあると推測できる\n英語は他の二教科に比べて理解度にバラツキがないと推測できる\n数学は他の二教科に比べて理解度が全体的位低い可能性がある\n\nもしくは難易度が高かった可能性がある\n\n\n\n　\nおまけ\n　基本統計量をまとめて計算するにはskimrパッケージのskimr::skim()関数が便利です。ただし、求められる標準偏差は母標準偏差の推定量です。\n\n基本統計量skimr::skim(x) %>% \n  df_print()"
  },
  {
    "objectID": "chapter00.html#個人演習層別ヒストグラムの作成",
    "href": "chapter00.html#個人演習層別ヒストグラムの作成",
    "title": "【序】なぜ、統計手法が必要か",
    "section": "個人演習（層別ヒストグラムの作成）",
    "text": "個人演習（層別ヒストグラムの作成）\nQ3 ヒストグラムを作成して比較する（演習1）\n　層別のヒストグラムを描くにはggplot2パッケージが便利です。ここでは階級幅を\\(10\\mbox{点}\\)としています。\n\n層別ヒストグラムx %>% \n  tidyr::pivot_longer(cols = dplyr::everything(),\n                      names_to = \"教科\", values_to = \"得点\") %>% \n  dplyr::mutate(教科 = forcats::fct_inorder(教科)) %>% \n  ggplot2::ggplot(ggplot2::aes(x = 得点, fill = 教科)) + \n    ggplot2::geom_histogram(breaks = seq(0, 100, 10), alpha = 0.5) + \n    ggplot2::facet_grid(rows = dplyr::vars(教科))\n\n\n\n\n　\nヒストグラムの調整比較\n　Microsoft Excel（2016以降）ではヒストグラムを描くことができますが、グラフ表示の調整には制限があります。Excelでヒストグラム間の比較を行いたい場合は小池方式のテクニックを使う必要がありますが、他のツールでは調整が可能です。\n\n\n\n\n\n\n\n\n\nツール名\n階級幅\n階級（横軸）\n度数（縦軸）\n閉じ1\n\n\n\n\nMicrosoft Excel(365)\n調整可\n調整不可\n調整不可\n調整不可\n\n\nGoogle Spreadsheet\n調整可\n調整可\n調整可\n調整不可\n\n\nBase R (hist)\n調整可\n調整可\n調整可\n調整可\n\n\nR/Tidyverse (ggplot2)\n調整可\n調整可\n調整可\n調整可\n\n\n\n1 閉じとは階級の境界にあたるデータの処理方法です。\\(a < x \\le b\\)を右閉じ、\\(a \\le x < b\\)を左閉じといい、右閉じが主流です。"
  },
  {
    "objectID": "chapter00.html#グループ演習2同じ30点でも",
    "href": "chapter00.html#グループ演習2同じ30点でも",
    "title": "【序】なぜ、統計手法が必要か",
    "section": "グループ演習2（同じ30点でも）",
    "text": "グループ演習2（同じ30点でも）\n\n\n統計量\n国語\n数学\n英語\n備考\n\n\n\n平均\n50\n25\n50\n\n\n\n分散\n101\n101\n26\n母分散\n\n\n標準偏差\n10\n10\n5\n標準偏差の推定値\n\n\n変動係数\n0.20\n0.40\n0.10\n\n\n\n中央値\n50\n25\n50\n第二四分位値（参考）\n\n\n\n\n層別ヒストグラムx %>% \n  tidyr::pivot_longer(cols = dplyr::everything(),\n                      names_to = \"教科\", values_to = \"得点\") %>% \n  dplyr::mutate(教科 = forcats::fct_inorder(教科)) %>% \n  ggplot2::ggplot(ggplot2::aes(x = 得点, fill = 教科)) + \n    ggplot2::geom_histogram(breaks = seq(0, 100, 10), alpha = 0.5) + \n    ggplot2::facet_grid(rows = dplyr::vars(教科)) + \n    ggplot2::geom_vline(xintercept = 30, colour = \"red\", size = 0.25)\n\n\n\n\n　上記より30点という得点は以下のように判断できます。\n\n国語は悪い得点\n\n\n\\(\\mu - 2\\sigma\\)なので\n\n\n数学はまあまあの得点\n\n\n\\(\\mu + 1\\sigma\\)以内なのですごく良いとは言えない（まあ平均的）\n\n\n英語は非常に悪い得点\n\n\n\\(\\mu - 3\\sigma\\)の外側なので本来ならありえない（実際データにはない）\n\n\n\nまた、以下のようなことも推測できます。\n\n数学は50点以上の得点を取得したものほぼいないことから難しい問題\n\nもしくは、全体の理解度が低い\n\n\n英語は標準偏差が他の二教科に比べると小さいので全体の理解度がある程度の水準にある\n\nもしくは、極端に難しい問題が半分くらいある"
  },
  {
    "objectID": "chapter00.html#個人演習テスト結果を比べる",
    "href": "chapter00.html#個人演習テスト結果を比べる",
    "title": "【序】なぜ、統計手法が必要か",
    "section": "個人演習（テスト結果を比べる）",
    "text": "個人演習（テスト結果を比べる）\n　対象データは下記の通り。\n\n三教科の平均点と標準偏差x <- \"./data/Pre_P37_個人演習.csv\" %>% \n  read.csv()\n\nx %>% df_print()\n\n\n\n  \n\n\n\n　\nQ1 成績の良い順に並べる（演習2）\n　Zスコアと偏差値を算出して成績の良い順に並べる。\n\nZスコアと偏差値を求めるx %>% \n  dplyr::mutate(Z = (得点 - 平均点) / 標準偏差,\n                偏差値 = Z * 10 + 50) %>% \n  dplyr::arrange(dplyr::desc(偏差値)) %>% \n  df_print()\n\n\n\n  \n\n\n\n　\nQ2 相対順位を算出する（演習2）\n　Zスコアから相対順位（上位\\(%\\))を求める。\n\n相対順位x %>% \n  dplyr::mutate(Z = (得点 - 平均点) / 標準偏差,\n                偏差値 = Z * 10 + 50,\n                相対順位 = round((1 - pnorm(Z)) * 100)) %>% \n  df_print(ｄ)\n\n\n\n  \n\n\n\n　\nQ3 SECデータ白書のベンチワーク（演習2）\n\n\n\n\n  \n\n\n\n\n計算結果x %>% \n  dplyr::mutate(Zスコア = (評価対象 - 平均) / 標準偏差,\n                上位パーセンテージ = (1 - pnorm(Zスコア)) * 100,\n                偏差値 = Zスコア * 10 + 50) %>% \n  df_print()"
  },
  {
    "objectID": "chapter00.html#グループ演習3二群のデータの違いによるp値比較",
    "href": "chapter00.html#グループ演習3二群のデータの違いによるp値比較",
    "title": "【序】なぜ、統計手法が必要か",
    "section": "グループ演習3（二群のデータの違いによるp値比較）",
    "text": "グループ演習3（二群のデータの違いによるp値比較）\n\n4パターンの二群のデータx <- \"./data/Pre_P53_2群のデータ.csv\" %>% \n  read.csv()\n\nx %>% df_print()\n\n\n\n  \n\n\n\n\n4パターンの二群のデータ\"./data/Pre_P52_4パターン.csv\" %>% \n  read.csv() %>% \n  ggplot2::ggplot(ggplot2::aes(x = Group, y = Value, colour = Group)) +\n    ggplot2::geom_jitter(position = \"dodge\") +\n    ggplot2::facet_grid(~ Pattern)\n\nWarning: Width not defined. Set with `position_dodge(width = ?)`\n\n\n\n\n\n　\nQ1 グラフから結果を予想する（演習3）\n　グラフから結果を予想するにあたり、データの分布が見やすい箱ひげ図を描いておきます。\n\n4パターンの二群のデータ\"./data/Pre_P52_4パターン.csv\" %>% \n  read.csv() %>% \n  ggplot2::ggplot(ggplot2::aes(x = Group, y = Value, colour = Group)) +\n    ggplot2::geom_boxplot(position = \"dodge\") +\n    ggplot2::facet_grid(~ Pattern)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nパターン1とパターン2は\n\nデータ数は等しい\nパターン2の方が標準偏差が小さい（分離性が高い）\n\n\n\n\\[\\mbox{パターン2} < \\mbox{パターン1}\\]\n\nパターン2とパターン4は\n\n標準偏差は等しい\nパターン4の方がデータ数が少ない（半分以下）\n\n\n\n\\[\\mbox{パターン2} < \\mbox{パターン4}\\]\n\nパターン2とパターン3は\n\nパターン2の方が標準偏差が小さい（約半分）\nパターン3の方がデータ数が多い（倍）\n\n\n\n\\[\\mbox{パターン2} < \\mbox{パターン3}\\]\n\nパターン3とパターン4は\n\n標準偏差は同じ\nパターン4の方がデータ数が少ない（半分以下）\n\n\n\n\\[\\mbox{パターン3} < \\mbox{パターン4}\\]\n\nパターン1とパターン4は\n\nパターン1の方がデータ数が多い（倍以上）\nパターン4の方が標準偏差が小さい（約半分）\n\n\n\n\\[\\mbox{パターン4} < \\mbox{パターン1}\\]\nしたがって、4パターンのp値の関係は以下と推測できる。\n\\[\\mbox{パターン2} < \\mbox{パターン3} < \\mbox{パターン4} < \\mbox{パターン1}\\]\n　\nQ2 t検定のp値で結果を確認する（演習3）\n　Rで二群の平均値の差の検定を行うにはt.test()関数を用います。\n\nパターン1のt検定結果\"./data/Pre_P53_パターン1.csv\" %>% \n  read.csv() %>% \n  with(t.test(Value ~ Group, var.equal = TRUE))\n\n\n    Two Sample t-test\n\ndata:  Value by Group\nt = -1.5492, df = 16, p-value = 0.1409\nalternative hypothesis: true difference in means between group  A and group  B is not equal to 0\n95 percent confidence interval:\n -0.4736786  0.0736786\nsample estimates:\nmean in group  A mean in group  B \n             1.0              1.2 \n\n\n\nパターン2のt検定結果\"./data/Pre_P53_パターン2.csv\" %>% \n  read.csv() %>% \n  with(t.test(Value ~ Group, var.equal = TRUE))\n\n\n    Two Sample t-test\n\ndata:  Value by Group\nt = -3.0984, df = 16, p-value = 0.006903\nalternative hypothesis: true difference in means between group  A and group  B is not equal to 0\n95 percent confidence interval:\n -0.3368393 -0.0631607\nsample estimates:\nmean in group  A mean in group  B \n             1.0              1.2 \n\n\n\nパターン3のt検定結果\"./data/Pre_P53_パターン3.csv\" %>% \n  read.csv() %>% \n  with(t.test(Value ~ Group, var.equal = TRUE))\n\n\n    Two Sample t-test\n\ndata:  Value by Group\nt = -2.26, df = 34, p-value = 0.03034\nalternative hypothesis: true difference in means between group  A and group  B is not equal to 0\n95 percent confidence interval:\n -0.37984565 -0.02015435\nsample estimates:\nmean in group  A mean in group  B \n        1.003889         1.203889 \n\n\n\nパターン4のt検定結果\"./data/Pre_P53_パターン4.csv\" %>% \n  read.csv() %>% \n  with(t.test(Value ~ Group, var.equal = TRUE))\n\n\n    Two Sample t-test\n\ndata:  Value by Group\nt = -2.0927, df = 6, p-value = 0.08129\nalternative hypothesis: true difference in means between group  A and group  B is not equal to 0\n95 percent confidence interval:\n -0.43384763  0.03384763\nsample estimates:\nmean in group  A mean in group  B \n             1.0              1.2 \n\n\n\nt検定結果の比較（p値順）\"./data/Pre_P52_4パターン.csv\" %>% \n  read.csv() %>% \n  dplyr::group_by(Pattern) %>% \n  tidyr::nest() %>% \n  dplyr::mutate(out = purrr::map(.x = data,\n                                 .f = ~ with(.x, t.test(Value ~ Group,\n                                                        var.equal = TRUE) %>% \n                                               broom::tidy()))) %>% \n  tidyr::unnest(out) %>% \n  dplyr::select(Pattern, p.value, t.value = statistic) %>% \n  dplyr::arrange(p.value) %>% \n  dplyr::left_join(x, by = c(\"Pattern\" = \"パターン\")) %>% \n  df_print()"
  },
  {
    "objectID": "chapter00.html#個人演習ツール導入すべきか",
    "href": "chapter00.html#個人演習ツール導入すべきか",
    "title": "【序】なぜ、統計手法が必要か",
    "section": "個人演習（ツール導入すべきか？）",
    "text": "個人演習（ツール導入すべきか？）\n　ツール導入前後の欠陥密度データです。データ間に対応はありません。\n\nツール導入前後の欠陥密度\"./data/Pre_P13_ツールを導入すべきか.csv\" %>% \n  read.csv() %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n　欠陥密度の平均値の差は\\(0.5\\)なので約\\(17\\%\\)改善していることになります。\n\nツール導入前後の欠陥密度の平均値\"./data/Pre_P13_ツールを導入すべきか.csv\" %>% \n  read.csv() %>% \n  dplyr::summarise(dplyr::across(dplyr::everything(), mean)) %>% \n  df_print()\n\n\n\n  \n\n\n\n　\nQ1 t検定で検証する （演習4）\n　ツール導入前後の欠陥密度に優位な差があるかをt検定で検証します。なお、両者のデータは等分散であると仮定、有意水準は\\(5\\%\\)とします。\n\n欠陥密度の平均値の差の検定\"./data/Pre_P13_ツールを導入すべきか.csv\" %>% \n  read.csv() %>% \n  with(t.test(導入前, 導入後, var.equal = TRUE))\n\n\n    Two Sample t-test\n\ndata:  導入前 and 導入後\nt = 2.0761, df = 8, p-value = 0.07154\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n -0.05535934  1.05535934\nsample estimates:\nmean of x mean of y \n      3.0       2.5 \n\n\n　p値が有意水準を下回らないので、帰無仮説は棄却できず有意な差がある（二群の平均値の差が\\(0\\)でない）とは言えない。したがって、このデータからはツール導入の効果は見込めない。ただし、p値からみてデータ数を増やして再検定すれば有意になる可能性があるかも知れない。\n\n参考）欠陥密度の分布\"./data/Pre_P13_ツールを導入すべきか.csv\" %>% \n  read.csv() %>% \n  tidyr::pivot_longer(cols = dplyr::everything(),\n                      names_to = \"type\", values_to = \"value\") %>% \n  ggplot2::ggplot(ggplot2::aes(x = type, y = value, colour = type)) +\n    ggplot2::geom_jitter(position = \"dodge\")\n\nWarning: Width not defined. Set with `position_dodge(width = ?)`"
  },
  {
    "objectID": "chapter01.html",
    "href": "chapter01.html",
    "title": "\n1  度数分布表とヒストグラムでデータの特徴を浮き彫りにする\n",
    "section": "",
    "text": "テキストP16の図表1-1のデータは4列20行からなるデータです。\n\n\n\n\n  \n\n\n\n　\n　Rでは、このような形式のデータ（雑然データ）をそのまま使わずに整然データ（Tidy Data）と呼ばれる形式に変換した方が効率的に処理できます。変換にはtidyverseファミリーを利用するのが効率的です。\n\nTidy Dataへの変形library(tidyverse)  # load tidyverse package\n\nx <- \"./data/P16_図表1-1 .csv\" %>% \n  readr::read_csv(col_names = FALSE, show_col_types = FALSE) %>% \n  tidyr::pivot_longer(cols = dplyr::starts_with(\"X\"),\n                      names_to = \"name\", values_to = \"value\") %>% \n  dplyr::arrange(name) %>% \n  dplyr::select(height = value)\n\nx %>% \n  df_print()\n\n\n\n  \n\n\n\n　このような形式（Tidy Data）に変換することで、様々な統計量を効率的に求めることができるようになります。"
  },
  {
    "objectID": "chapter01.html#ヒストグラムを作る",
    "href": "chapter01.html#ヒストグラムを作る",
    "title": "\n1  度数分布表とヒストグラムでデータの特徴を浮き彫りにする\n",
    "section": "\n1.2 ヒストグラムを作る",
    "text": "1.2 ヒストグラムを作る\n　テキストでは度数分布表を作成してからヒストグラムを描いています。その手順は\n\n最大・最小値を求める\n階級を決める\n度数をカウントする\n相対度数を求める\n累積度数を求める\n\nここまでが度数分布表の作成\n\n\n度数分布表をもとにヒストグラムを描く\n\nとなっていますが、Rではhist()関数だけでヒストグラムを描くことができます。hist()関数の引数はベクトル型に限定されますので、データフレーム型の場合は参照演算子（$）などでベクトル型データを取り出す必要があります。\n\nR標準のヒストグラム関数hist(x = x$height)\n\n\n\n\n　\n　hist()関数はヒストグラムを描くために必要となる階級や度数、階級値などの情報を出力することも可能です。\n\n階級などを表示させる方法hist(x = x$height, plot = FALSE)\n\n$breaks\n[1] 140 145 150 155 160 165 170\n\n$counts\n[1]  1  6 19 30 18  6\n\n$density\n[1] 0.0025 0.0150 0.0475 0.0750 0.0450 0.0150\n\n$mids\n[1] 142.5 147.5 152.5 157.5 162.5 167.5\n\n$xname\n[1] \"x$height\"\n\n$equidist\n[1] TRUE\n\nattr(,\"class\")\n[1] \"histogram\"\n\n\n\n主な出力の意味\n\n\n\n\n\n\n出力名\n意味\n備考\n\n\n\n$breaks\n階級\nデフォルトはスタージェスの公式*後述にもとづく区切り（幅）\n\n\n$counts\n度数\n各階級に入るデータの個数\n\n\n$density\n密度\n密度推定値\n\n\n$mids\n階級値\n階級の中央値（階級の単純平均）\n\n\n\n　\n　表形式の度数分布表を作成する場合は以下のようにコード処理します。\n\n度数分布表の作成x %>% \n  # 階級を求めて、データを階級ごとに分ける\n  dplyr::mutate(class = cut(height,\n                            breaks = pretty(height, n = nclass.Sturges(height)),\n                            include.lowest = FALSE, right = TRUE)) %>% \n  # 階級ごとの度数を求める\n  dplyr::count(class) %>% \n  # 累積度数、相対度数、累積相対度数を求める\n  dplyr::mutate(cumsum_n = cumsum(n),\n                prop = prop.table(n), cumsum_prop = cumsum(prop)) %>% \n  # 階級値を求める\n  dplyr::mutate(class_value = as.character(class)) %>%\n  tidyr::separate(class_value, into = c(\"l\", \"h\"), sep = \",\") %>% \n  dplyr::mutate(l = as.integer(stringr::str_remove(l, \"[[:punct:]]\")) + 1L,\n                h = as.integer(stringr::str_remove(h, \"[[:punct:]]\")),\n                mids = (l + h) / 2L) %>%\n  # 変数名を日本語にする\n  dplyr::select(`階級` = class, `階級値` = mids,\n                `度数` = n, `累積度数` = cumsum_n,\n                `相対度数` = prop, `累積相対度数` = cumsum_prop) %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n　以降の項は度数分布表の作成に必要な関数の使い方を紹介していますので、不要な方は演習問題まで読み飛ばしてください。\n　\n\n1.2.1 階級を求める\n\n以降に出てくるwith()関数は、第一引数で指定するデータフレーム型変数内の変数名を第二引数内で参照演算子（$）を用いることなく参照できるようにする関数です。\n\n　階級を求めるにはpretty()関数を使います。\n\n階級を求めるwith(x, pretty(x = height,\n               n = nclass.Sturges(height)))\n\n[1] 140 145 150 155 160 165 170\n\n\n　第一引数xには階級を求めたいベクトル型データを第二引数nには階級を区切りたい数（階級数）を指定します。ここでは、階級数nにはスタージェスの公式から求めた階級数を指定しています。\n　ただし、xで指定したデータが階級に収まるように適切な丸め処理を行いますので、指定した階級数とは異なる階級が求められることもあります。\n　スタージェスの公式は、階級数を\\(k\\)、データのサイズ（数）を\\(n\\)とした場合、下式で定義されます。\n\\[k = \\lceil \\log_2n + 1 \\rceil\\]\n　スタージェスの公式はnclass.Sturgess()関数として実装されています。\n\nスタージェスの公式に基づく階級数with(x, nclass.Sturges(height))\n\n[1] 8\n\n\n　\n　スタージェスの公式はヒストグラムを平滑化し過ぎる傾向があると言われています。気になる場合はスコットの選択（nclass.scott()）やフリードマン=ダイアコニスの選択（nclass.FD()）を試して見てください。\n　\n\n1.2.2 データを各階級に分類する\n\n\n参考）身長データ（元データ）with(x, height)\n\n [1] 151 154 160 160 163 156 158 156 154 160 154 162 156 162 157 162 162 169 150\n[20] 162 152 161 159 164 168 153 160 155 160 158 160 150 163 155 157 162 154 161\n[39] 153 154 151 155 158 146 149 165 169 154 155 166 165 161 148 143 156 162 158\n[58] 156 159 164 167 159 157 151 159 156 151 160 153 156 146 166 151 159 157 156\n[77] 162 156 156 161\n\n　\n　データを階級分けするにはcut()関数を使います。\n\nデータの階級分けwith(x, cut(x = height,\n            breaks = pretty(height,\n                            n = nclass.Sturges(height))))\n\n [1] (150,155] (150,155] (155,160] (155,160] (160,165] (155,160] (155,160]\n [8] (155,160] (150,155] (155,160] (150,155] (160,165] (155,160] (160,165]\n[15] (155,160] (160,165] (160,165] (165,170] (145,150] (160,165] (150,155]\n[22] (160,165] (155,160] (160,165] (165,170] (150,155] (155,160] (150,155]\n[29] (155,160] (155,160] (155,160] (145,150] (160,165] (150,155] (155,160]\n[36] (160,165] (150,155] (160,165] (150,155] (150,155] (150,155] (150,155]\n[43] (155,160] (145,150] (145,150] (160,165] (165,170] (150,155] (150,155]\n[50] (165,170] (160,165] (160,165] (145,150] (140,145] (155,160] (160,165]\n[57] (155,160] (155,160] (155,160] (160,165] (165,170] (155,160] (155,160]\n[64] (150,155] (155,160] (155,160] (150,155] (155,160] (150,155] (155,160]\n[71] (145,150] (165,170] (150,155] (155,160] (155,160] (155,160] (160,165]\n[78] (155,160] (155,160] (160,165]\nLevels: (140,145] (145,150] (150,155] (155,160] (160,165] (165,170]\n\n\n　\n　cut()関数の第一引数xには階級分けの対象となるベクトル型変数を第二引数breaksには前項で求めた階級を指定します。breaks引数には任意の階級、例えばbreaks = c(140, 155, 170)のような指定も可能です。\n　\n階級の境界値はどちらに含まれるのか？\n　cut()関数の出力は、(140,145] (145,150]のように階級間で同じ値（この場合は145）が含まれます。では、145はどちらの階級に含まれるのでしょうか？答えは、添えられている括弧にあります。\n\n(140,145]\n\nは「140を超えて145以下」となりますので、次の\n\n(145,150]\n\nは同様に「145を超えて150以下」となります。階級間の境界値である145は(140, 145]側に入ります。\n\n(は「超えて」（境界値を含まない）、]は「以下」（境界値を含む）\n\nで、逆向きの場合は\n\n)は「未満」（境界値を含まない）、[は「以上」（境界値を含む）\n\nとなります。hist()関数の階級も同様です。\n　境界値をどちらに含めるかはinclude.lowest引数とright引数で指定できます。\n\n\n\n\n\n\n\noption\n\nright = TRUE 　\nright = FALSE\n\n\n\ninclude.lowest = TRUE\n[l,u] ... (l,u]\n[l,u) ... [l,u]\n\n\ninclude.lowest = FALSE\n\n(l,u] ... (l,u]*\n\n[l,u) ... [l,u)\n\n\n\n　*デフォルト\n　例えばデータの最大値と最小値を境界値として含む階級を指定した場合、include.lowest = FALSE, right = FALSEと指定すると最大値が階級に含まれなくなる場合があります。\n\n以上、未満の場合with(x, cut(height, breaks = c(143, 155, 169),\n            include.lowest = FALSE, right = FALSE))\n\n [1] [143,155) [143,155) [155,169) [155,169) [155,169) [155,169) [155,169)\n [8] [155,169) [143,155) [155,169) [143,155) [155,169) [155,169) [155,169)\n[15] [155,169) [155,169) [155,169) <NA>      [143,155) [155,169) [143,155)\n[22] [155,169) [155,169) [155,169) [155,169) [143,155) [155,169) [155,169)\n[29] [155,169) [155,169) [155,169) [143,155) [155,169) [155,169) [155,169)\n[36] [155,169) [143,155) [155,169) [143,155) [143,155) [143,155) [155,169)\n[43] [155,169) [143,155) [143,155) [155,169) <NA>      [143,155) [155,169)\n[50] [155,169) [155,169) [155,169) [143,155) [143,155) [155,169) [155,169)\n[57] [155,169) [155,169) [155,169) [155,169) [155,169) [155,169) [155,169)\n[64] [143,155) [155,169) [155,169) [143,155) [155,169) [143,155) [155,169)\n[71] [143,155) [155,169) [143,155) [155,169) [155,169) [155,169) [155,169)\n[78] [155,169) [155,169) [155,169)\nLevels: [143,155) [155,169)\n\n\n　\n　逆にinclude.lowest = FALSE, right = TRUEと指定すると最小値が階級が階級に含まれなくなる場合があります。\n\n超えて、以下の場合with(x, cut(height, breaks = c(143, 155, 169),\n            include.lowest = FALSE, right = TRUE))\n\n [1] (143,155] (143,155] (155,169] (155,169] (155,169] (155,169] (155,169]\n [8] (155,169] (143,155] (155,169] (143,155] (155,169] (155,169] (155,169]\n[15] (155,169] (155,169] (155,169] (155,169] (143,155] (155,169] (143,155]\n[22] (155,169] (155,169] (155,169] (155,169] (143,155] (155,169] (143,155]\n[29] (155,169] (155,169] (155,169] (143,155] (155,169] (143,155] (155,169]\n[36] (155,169] (143,155] (155,169] (143,155] (143,155] (143,155] (143,155]\n[43] (155,169] (143,155] (143,155] (155,169] (155,169] (143,155] (143,155]\n[50] (155,169] (155,169] (155,169] (143,155] <NA>      (155,169] (155,169]\n[57] (155,169] (155,169] (155,169] (155,169] (155,169] (155,169] (155,169]\n[64] (143,155] (155,169] (155,169] (143,155] (155,169] (143,155] (155,169]\n[71] (143,155] (155,169] (143,155] (155,169] (155,169] (155,169] (155,169]\n[78] (155,169] (155,169] (155,169]\nLevels: (143,155] (155,169]\n\n\n　\n\n1.2.3 度数を求める\n　度数を求めるには各階級の数を数えます。数を数えるにはtable()関数やdplyr::count()関数を使います。table()関数はベクトル型を対象として、dplyr::count()関数はデータフレーム型を対象として個数をカウントする関数です。\n\n度数のカウントwith(x, table(cut(height,\n                  breaks = pretty(height,\n                                  n = nclass.Sturges(height)))))\n\n\n(140,145] (145,150] (150,155] (155,160] (160,165] (165,170] \n        1         6        19        30        18         6 \n\n\n\n度数のカウント（データフレームの場合）x %>% \n  dplyr::mutate(class = cut(height,\n                            breaks = pretty(height,\n                                            n = nclass.Sturges(height)))) %>% \n  dplyr::count(class) %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n\n1.2.4 累積度数、相対度数、累積相対度数を求める\n　累積度数（度数の累積和）を求めるにはcumsum()関数を使います。\n\n累積度数を求めるwith(x, cumsum(table(cut(height,\n                         breaks = pretty(height,\n                                         n = nclass.Sturges(height))))))\n\n(140,145] (145,150] (150,155] (155,160] (160,165] (165,170] \n        1         7        26        56        74        80 \n\n\n　\n　相対度数を求めるにはprop.table()関数を使います。\n\n相対度数を求めるwith(x, prop.table(table(cut(height,\n                             breaks = pretty(height,\n                                             n = nclass.Sturges(height))))))\n\n\n(140,145] (145,150] (150,155] (155,160] (160,165] (165,170] \n   0.0125    0.0750    0.2375    0.3750    0.2250    0.0750 \n\n\n　累積相対度数は相対度数の累積和ですので、prop.table()関数の結果をcumsum()関数に渡すことで求めることができます。\n\n累積相対度数を求めるwith(x, cumsum(prop.table(\n  table(cut(height,\n            breaks = pretty(height,\n                            n = nclass.Sturges(height)))))))\n\n(140,145] (145,150] (150,155] (155,160] (160,165] (165,170] \n   0.0125    0.0875    0.3250    0.7000    0.9250    1.0000 \n\n\n　\n\n1.2.5 階級値を求める\n　階級値は階級の文字列から下端と上端の境界値を抜き出し、下式で単純平均として求めています。\n\\[\\frac{(\\mbox{下端} + 1) + \\mbox{上端}}{2}\\]\n　手順としては以下のようになります。\n\n\nas.character()関数で 階級（class）を文字型に変換し、新しい変数（class_value）を作成する\n\n\ntidyr::separate()関数で文字型の変数（class_value）を,の前後で二つの変数（l, h）に分割する\n\n\nstringr::str_remove関数で二つの変数（l, h）から(や]を取り除きas.numeric()関数で文字列から数値に変換する\n\n数値に変換された二つの変数から（l, h）平均値を求める\n\n\n階級値を求めるx %>% \n  # 階級を求めて、データを階級ごとに分ける\n  dplyr::mutate(class = cut(height,\n                            breaks = pretty(height,\n                                            n = nclass.Sturges(height)),\n                            include.lowest = FALSE,\n                            right = TRUE)) %>% \n  # 階級ごとの度数を求める\n  dplyr::count(class) %>% \n  # 階級値を求める\n  dplyr::mutate(class_value = as.character(class)) %>% \n  tidyr::separate(class_value, into = c(\"l\", \"h\"), sep = \",\") %>% \n  dplyr::mutate(l = as.numeric(stringr::str_remove(l, \"[[:punct:]]\")),\n                h = as.numeric(stringr::str_remove(h, \"[[:punct:]]\"))) %>% \n  dplyr::mutate(mids = ((l + 1) + h) / 2) %>% \n  df_print()"
  },
  {
    "objectID": "chapter01.html#練習問題",
    "href": "chapter01.html#練習問題",
    "title": "\n1  度数分布表とヒストグラムでデータの特徴を浮き彫りにする\n",
    "section": "\n1.3 練習問題",
    "text": "1.3 練習問題\n　テキストP23にあるデータで度数分布表とヒストグラムを作成する。\n\n\n\n\n  \n\n\n\n　\n解答例\n　まず、処理しやすいように下記のように対象データを変形しdfというデータフレーム型の変数に格納しておきます。\n\n\n\n\n整形済の処理対象データ（体重データ）df %>% \n  df_print()\n\n\n\n  \n\n\n\n　度数分布表を身長の場合と同じ要領で作成します。\n\n度数分布表の作成df %>% \n  dplyr::mutate(class = cut(weight,\n                            breaks = pretty(weight,\n                                            n = nclass.Sturges(weight)),\n                            include.lowest = FALSE,\n                            right = TRUE)) %>% \n  # 階級ごとの度数を求める\n  dplyr::count(class) %>% \n  # 累積度数、相対度数、累積相対度数を求める\n  dplyr::mutate(cumsum_n = cumsum(n),\n                prop = prop.table(n),\n                cumsum_prop = cumsum(prop)) %>% \n  # 階級値を求める\n  dplyr::mutate(class_value = as.character(class)) %>%\n  tidyr::separate(class_value, into = c(\"l\", \"h\"), sep = \",\") %>% \n  dplyr::mutate(l = as.integer(stringr::str_remove(l, \"[[:punct:]]\")) + 1L,\n                h = as.integer(stringr::str_remove(h, \"[[:punct:]]\")),\n                mids = (l + h) / 2L) %>%\n  # 変数名を日本語にする\n  dplyr::select(`階級` = class, `階級値` = mids,\n                `度数` = n, `累積度数` = cumsum_n,\n                `相対度数` = prop,\n                `累積相対度数` = cumsum_prop) %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n　ヒストグラムを描きます。\n\nヒストグラムを描くwith(df, hist(weight))\n\n\n\n\n　\n以上"
  },
  {
    "objectID": "chapter01.html#ヒストグラムを描くポイント",
    "href": "chapter01.html#ヒストグラムを描くポイント",
    "title": "\n1  度数分布表とヒストグラムでデータの特徴を浮き彫りにする\n",
    "section": "ヒストグラムを描くポイント",
    "text": "ヒストグラムを描くポイント\n　ヒストグラムを描く（度数分布表を作成する）際のポイントは下記の点です。\n\n階級の決め方\n階級の境界の扱い\n\n　\n階級の決め方\n　階級を決める方法は特に定められていません。データが取る幅を見て切のよい値にすることが多いようです。ただし、階級のとり方によりヒストグラムの形状が変わる点には注意が必要です。例えば、身長データに対する階級をテキストと同様に\\(5cm\\)幅とした場合は下図のような形状になります。\n\n階級幅5cmの場合のヒストグラムwith(x, hist(height,\n             breaks = seq(from = 140, to = 170, by = 5)))\n\n\n\n\n　\n　階級を倍の\\(10cm\\)幅とすると下図のようになります。\n\n階級幅10cmの場合のヒストグラムwith(x, hist(height,\n             breaks = seq(from = 140, to = 170, by = 10)))\n\n\n\n\n　\n　逆に階級を半分の\\(2.5cm\\)幅とすると下図のようになります。\n\n階級幅2.5cmの場合のヒストグラムwith(x, hist(height,\n             breaks = seq(from = 140, to = 170, by = 2.5)))\n\n\n\n\n　\n　更に細かくして\\(1cm\\)幅にすると下図のように歯抜けがある形状になります。\n\n階級幅1cmの場合のヒストグラムwith(x, hist(height,\n             breaks = seq(from = 140, to = 170, by = 1.0)))\n\n\n\n\n　\n　このように階級の決め方次第でヒストグラムの形状が変わってくることが分かります。ヒストグラムはデータの分布をみるために使うグラフですので、過大な階級幅や過小な階級幅で描くことは好ましくありませんので、適切な値を選ぶようにしてください。\n　\n計算で階級を決める\n　適切な階級をどのように決めれば良いか迷う場合には、下表のような計算方法が提案されていますのでこれらを試してみてください。\n\n\n\n\n\n\n\n階級の求め方\n階級数（\\(k\\)）・階級幅（\\(h\\)）\n備考\n\n\n\n平方根選択（Square-root choice）\n\\(k = \\sqrt{n}\\)\n\n\n\nスタージェスの公式（Sturges’s formula）\n\\(k = \\lceil \\log_2n + 1 \\rceil\\)\n\n\\(n \\geq 30\\)が前提\n\n\nスコットの選択（Scott’s choice）\n\\(h = \\frac{3.5\\sigma}{n^{1/3}}\\)\n\n\n\nフリードマン・ダイアコニスの選択（F-D’s choice）\n\\(h = 2\\frac{IQR(x)}{n^{1/3}}\\)\n\n\n\n\n階級数（\\(k\\)）から階級幅（\\(h\\)）を求める場合は下式を使います。 \\[h = \\lceil \\frac{max(x) - min(x)}{k} \\rceil\\] \\(k\\) :階級の数\\(h\\) :階級の幅\\(n\\) :データの個数\\(\\lceil x \\rceil\\) :天井関数（実数\\(x\\)に対して\\(x\\)以上の最小の整数を返す関数）\\(\\sigma\\) :標準偏差\\(IQR\\) :四分位範囲\n数式出典：Wikipedia\n　\nスタージェスの公式\n　スタージェスの公式は、比較的、よく使われる計算方法です。ただし、データの数が\\(30\\)個未満の場合には適切ではありませんし、データの数が多くなるとヒストグラムを平滑化し過ぎる傾向があると言われています。そのような傾向が見られた場合には、他の計算方法や任意の階級も試してみてください。\n\n階級数をスタージェスの公式で求めた場合のヒストグラムwith(x, hist(height,\n             breaks = \"Sturges\"))\n\n\n\n\n　\nスコットの選択\n　スコットの選択は、データによってはスタージェスの公式と比べて階級数が少なくなる傾向があります。\n\n階級数をスコットの選択を元に求めた場合のヒストグラムwith(x, hist(height, breaks = \"Scott\"))\n\n\n\n\n　\nフリードマン・ダイアコニスの選択\n　フリードマン・ダイアコニスの法則とも呼ばれます。\n\n階級数をフリードマン・ダイアコニスの選択を元に求めた場合のヒストグラムwith(x, hist(height, breaks = \"FD\"))\n\n\n\n\n　\n階級の境界の扱い\n　階級は下表のように「下端値〜上端値」の形式で表示されることが多いですが、\\(140\\)は階級に含まれるのか？\\(145\\)はどちらの階級に含まれるのか？を決めておかないと意図しない度数になってしまう場合があります。\n\n\n階級\n度数\n\n\n\n140〜145\n1\n\n\n145〜150\n6\n\n\n…\n…\n\n\n160〜165\n16\n\n\n165〜170\n6\n\n\n\n　例えば、階級を「\\(\\mbox{下端値} < x \\leq \\mbox{上端値}\\)」と定義した場合は、下図のようになります。\n\n階級の上端を含める場合のヒストグラムwith(x, hist(height, right = TRUE))\n\n\n\n\n階級を「\\(\\mbox{下端値} \\leq x < \\mbox{上端値}\\)」と定義した場合は、分布形状が異なることが分かります。\n\n階級の下端を含める場合のヒストグラムwith(x, hist(height, right = FALSE))\n\n\n\n\n　このように階級によりヒストグラムの形状が変わってくる点には注意が必要です。なお、下端、上端の含め方を「左閉じ、右閉じ」と表現することもあります。"
  },
  {
    "objectID": "chapter01.html#等間隔ではない階級",
    "href": "chapter01.html#等間隔ではない階級",
    "title": "\n1  度数分布表とヒストグラムでデータの特徴を浮き彫りにする\n",
    "section": "等間隔ではない階級",
    "text": "等間隔ではない階級\n　度数分布表の階級は必ずしも等間隔である必要はありません。例えば、下図の世帯貯蓄のように度数の小さい階級をまとめたヒストグラムをしばしば見かけます。等間隔でないは階級は（最小値と最大値で桁が数桁異なるなど）幅が広いデータにおいて、階級を細かくしたい場合や等幅の階級でグラフ化するとデータを読み取りにくい場合などに使われます。\n（出典：なるほど統計学園）\n　このように階級幅が等間隔でない場合には、柱（棒）の面積が度数に対応するように高さを調整する必要があります。\n　ヒストグラムは棒グラフとは異なり階級ごとの柱（棒）の面積が意味を持っています。高さは一般的に度数として表示されますが、密度として表示することもあります。高さ（密度）と幅（階級幅）を乗じたものが相対度数になります。相対度数は名前の通り度数に比例していますので、柱（棒）の面積が等しければ同じ度数ということを表します。\n　\n　例えば、テキストにある身長のデータの\\(140cm\\)から\\(150cm\\)をひとつの階級にまとめた場合、度数分布表は下表のようになります。\n\n等間隔ではない階級の度数分布表x %>% \n  dplyr::mutate(class = cut(height,\n                            breaks = c(140, 150,\n                                       155, 160, 165, 170))) %>% \n  dplyr::count(class) %>% \n  dplyr::mutate(prop = prop.table(n)) %>% \n  dplyr::rename(`階級` = class, `度数` = n,\n                `相対度数` = prop) %>% \n  df_print()\n\n\n\n  \n\n\n\n　これをヒストグラムとして描いた場合は、下図のようにならなければなりません。この図では縦軸は度数でなく密度になっています。\n\n正しいヒストグラムwith(x, hist(height,\n             breaks = c(140, 150, 155, 160, 165, 170)))\n\n\n\n\n　密度（高さ）は左から\n　　0.00875, 0.0475, 0.075, 0.045, 0.015\n　となっていますので、これに個々の階級幅（幅）\n　　10, 5, 5, 5, 5\n　を乗じると個々の柱（棒）の面積は\n　　0.0875, 0.2375, 0.375, 0.225, 0.075\n　となり、相対度数と等しいことがわかります。　\n　度数を表示させるために下図のようなヒストグラムを描くことは好ましくありません。階級幅が等幅でない場合は度数分布表と共に密度のヒストグラムを示した方がよいでしょう。\n\n好ましくないヒストグラム（単なる棒グラフ）with(x, hist(height,\n             breaks = c(140, 150, 155, 160, 165, 170),\n             freq = TRUE))\n\nWarning in plot.histogram(r, freq = freq1, col = col, border = border, angle =\nangle, : プロットの領域が誤まりです。むしろ 'freq = FALSE' を使用して下さい"
  },
  {
    "objectID": "chapter02.html",
    "href": "chapter02.html",
    "title": "\n2  平均値とはやじろべえの視点である\n",
    "section": "",
    "text": "本講では以下のデータフレームを利用しています。"
  },
  {
    "objectID": "chapter02.html#統計量はデータを要約する数値",
    "href": "chapter02.html#統計量はデータを要約する数値",
    "title": "\n2  平均値とはやじろべえの視点である\n",
    "section": "\n2.1 統計量は、データを要約する数値",
    "text": "2.1 統計量は、データを要約する数値\n　本講で扱っている統計量（要約統計量）は平均のみです。"
  },
  {
    "objectID": "chapter02.html#平均値とは",
    "href": "chapter02.html#平均値とは",
    "title": "\n2  平均値とはやじろべえの視点である\n",
    "section": "\n2.2 平均値とは",
    "text": "2.2 平均値とは\n　本講の平均値とは算術平均を意味しています。身長データ（\\(x\\)）の平均値は157.575です。"
  },
  {
    "objectID": "chapter02.html#度数分布表での平均値",
    "href": "chapter02.html#度数分布表での平均値",
    "title": "\n2  平均値とはやじろべえの視点である\n",
    "section": "\n2.3 度数分布表での平均値",
    "text": "2.3 度数分布表での平均値\n\n第1講での度数分布表df %>% \n  dplyr::select(`階級` = class, `度数` = n, `階級値` = mids,\n                `階級幅` = range, `累積度数` = cumsum_n,\n                `相対度数` = prop, `累積相対度数` = cumsum_prop) %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n　（算術）平均は全ての観測値の総和を総データ数で除したものですので、観測値を各階級の代表値である階級値で近似すると下式が成り立つことが分かります。\n\\[\\mbox{平均} = \\frac{\\sum{\\mbox{観測値}_i}}{総データ数} = \\frac{\\sum{\\mbox{観測値}_i}}{\\sum{度数}_i}\\]\n\\[ \\fallingdotseq \\frac{\\sum{(\\mbox{階級値}_i \\times \\mbox{度数}_i)}}{\\sum{度数}_i} = \\sum{(\\mbox{階級値}_i \\times \\mbox{相対度数}_i)}\\]\n　なぜなら \\[\\frac{\\mbox{度数}_i}{\\sum{\\mbox{度数}_i}} = \\mbox{相対度数}_i\\]\n\\[i = 1, 2, ... , n\\]\n\nP26 図表2−1 階級数×相対度数df %>% \n  dplyr::select(A = mids, B = prop) %>% \n  dplyr::mutate(`A x B` = A * B) %>% \n  dplyr::rename(`A 階級値` = A, `B 相対度数` = B,\n                `A x B` = `A x B`) %>% \n  df_print()\n\n\n\n  \n\n\n\n\nP26 図表2−1 平均値df %>% \n  dplyr::select(A = mids, B = prop) %>% \n  dplyr::mutate(`A x B` = A * B) %>% \n  dplyr::summarise(`平均値` = sum(`A x B`)) %>% \n df_print()\n\n\n\n  \n\n\n\n　\n　実データで求めた平均値は157.575ですので、階級値から求めた平均値との差は-0.175となり、度数分布表を作ることは平均値に大きな影響を与えていないことが分かります。"
  },
  {
    "objectID": "chapter02.html#平均値のヒストグラムの中での役割",
    "href": "chapter02.html#平均値のヒストグラムの中での役割",
    "title": "\n2  平均値とはやじろべえの視点である\n",
    "section": "\n2.4 平均値のヒストグラムの中での役割",
    "text": "2.4 平均値のヒストグラムの中での役割\n　階級値から求めた平均値をヒストグラム上にプロットすると下図のようになります。\n\nヒストグラムにおける平均値with(x, hist(height))\nabline(v = 157.75, lty = 2)"
  },
  {
    "objectID": "chapter02.html#平均値をどう捉えるべきか",
    "href": "chapter02.html#平均値をどう捉えるべきか",
    "title": "\n2  平均値とはやじろべえの視点である\n",
    "section": "\n2.5 平均値をどう捉えるべきか",
    "text": "2.5 平均値をどう捉えるべきか\n　平均値の捉え方は様々考えられますが、テキストでは下記のようにまとめています。\n\n全データ（値）を代表する値（点）\nデータは平均値の周辺に分布する\n数多く現れるデータは平均値への影響が大きい\nデータの分布が対象の場合、平均値は対象軸"
  },
  {
    "objectID": "chapter02.html#練習問題",
    "href": "chapter02.html#練習問題",
    "title": "\n2  平均値とはやじろべえの視点である\n",
    "section": "\n2.6 練習問題",
    "text": "2.6 練習問題\n\n2.6.1 解答例\n\n相対度数と階級値×相対度数を求めるdata.frame(mids = c(30, 50, 70, 90, 110, 130),\n           n = c(5, 10, 15, 40, 20, 10)) %>% \n  dplyr::mutate(prop = prop.table(n), cm = mids * prop) %>% \n  dplyr::rename(`階級値` = mids, `度数` = n, `相対度数` = prop,\n                `階級値×相対度数` = cm) %>% \n  df_print()\n\n\n\n  \n\n\n\n\n平均値（階級数×相対度数の和）を求めるdata.frame(mids = c(30, 50, 70, 90, 110, 130),\n           n = c(5, 10, 15, 40, 20, 10)) %>% \n  dplyr::mutate(prop = prop.table(n), cm = mids * prop) %>% \n  dplyr::summarise(`平均値` = sum(cm)) %>% \n  df_print()"
  },
  {
    "objectID": "chapter02.html#コラム平均値のとり方は１つではない",
    "href": "chapter02.html#コラム平均値のとり方は１つではない",
    "title": "\n2  平均値とはやじろべえの視点である\n",
    "section": "【コラム】平均値のとり方は、１つではない",
    "text": "【コラム】平均値のとり方は、１つではない\n算術平均（Arithmetic Mean）\n\\[\\frac{\\sum_{i=1}^n{x_i}}{n}\\]\n\n計算式通りの求め方sum(c(10, 90)) / length(c(10, 90))\n\n[1] 50\n\n\n\n標準で組み込まれている関数mean(c(10, 90))\n\n[1] 50\n\n\n　\n幾何平均（Geometric Mean）または相乗平均\n\\[\\sqrt{\\prod_{i=1}^n{x_i}}\\]\n\n幾何平均はフローしやすいので専用関数でpsych::geometric.mean(c(10, 90))\n\n[1] 30\n\n\n　\n二乗平均（Root Mean Square）\n\\[\\sqrt{\\frac{\\sum_{i=1}^n{x_i^2}}{n}}\\]\n\n計算式通りの求め方sqrt(mean(c(10, 90) ^ 2))\n\n[1] 64.03124\n\n\n　\n　seewaveパッケージで二乗平均が関数として定義されていますが、コードの中身は上記のsqrt(mean(x ^ 2))と同一です。\n\nフロー対策などは施されていませんseewave::rms(c(10, 90))\n\n[1] 64.03124\n\n\n　\n調和平均（Harmonic Mean）\n\\[\\frac{n}{\\sum_{i=1}^n{\\frac{1}{x_i}}}\\]\n\nパッケージで提供されていますpsych::harmonic.mean(c(10, 90))\n\n[1] 18\n\n\n　\nトリム平均\n　トリム平均は体操競技の評点などで使われる平均値の計算方法で、値を小さい方から順に並べ、上位側と下位側から一定の割合で値を除き算術平均を求めます。外れ値や異常値などを影響を排除するために使われることが多いです。\n\n知っておくと便利なトリム平均mean(c(0, 1:8, 30))\n\n[1] 6.6\n\n知っておくと便利なトリム平均mean(c(0, 1:8, 30), trim = 0.25)  # データの両側2.5%を対象外とする\n\n[1] 4.5"
  },
  {
    "objectID": "chapter02.html#追加問題",
    "href": "chapter02.html#追加問題",
    "title": "\n2  平均値とはやじろべえの視点である\n",
    "section": "追加問題",
    "text": "追加問題\n　身長のデータを用いて階級幅が変わると度数分布表から求める平均値がどのように変化するか確認してみましょう。\n階級幅が倍になった場合\n\n階級幅が倍になった場合の平均値の差x %>% \n  dplyr::mutate(class = cut(height,\n                            breaks = c(140, 150, 160, 170),\n                            include.lowest = FALSE, right = TRUE)) %>% \n  dplyr::count(class) %>% \n  dplyr::mutate(class_value = as.character(class)) %>% \n  tidyr::separate(class_value, into = c(\"l\", \"h\"), sep = \",\") %>% \n  dplyr::mutate(l = as.numeric(stringr::str_remove(l, \"[[:punct:]]\")),\n                h = as.numeric(stringr::str_remove(h, \"[[:punct:]]\"))) %>% \n  dplyr::mutate(mids = ((l + 1) + h) / 2) %>% \n  dplyr::mutate(range = h - l, cumsum_n = cumsum(n),\n                prop = prop.table(n), cumsum_prop = cumsum(prop)) %>% \n  dplyr::select(A = mids, B = prop) %>% \n  dplyr::mutate(`A x B` = A * B) %>% \n  dplyr::summarise(`階級値による平均値` = sum(`A x B`)) %>% \n  dplyr::mutate(`算術平均` = mean(x$height),\n                `差` = `算術平均` - `階級値による平均値`) %>% \n  df_print()\n\n\n\n  \n\n\n\n階級幅が半分になった場合\n\n階級幅が半分になった場合の平均値の差x %>% \n  dplyr::mutate(class = cut(height,\n                            breaks = seq(from = 140, to = 170, by = 2.5),\n                            include.lowest = FALSE, right = TRUE)) %>% \n  dplyr::count(class) %>% \n  dplyr::mutate(class_value = as.character(class)) %>% \n  tidyr::separate(class_value, into = c(\"l\", \"h\"), sep = \",\") %>% \n  dplyr::mutate(l = as.numeric(stringr::str_remove(l, \"[[:punct:]]\")),\n                h = as.numeric(stringr::str_remove(h, \"[[:punct:]]\"))) %>% \n  dplyr::mutate(mids = ((l + 1) + h) / 2) %>% \n  dplyr::mutate(range = h - l, cumsum_n = cumsum(n),\n                prop = prop.table(n), cumsum_prop = cumsum(prop)) %>% \n  dplyr::select(A = mids, B = prop) %>% \n  dplyr::mutate(`A x B` = A * B) %>% \n  dplyr::summarise(`階級値による平均値` = sum(`A x B`)) %>% \n  dplyr::mutate(`算術平均` = mean(x$height),\n                `差` = `算術平均` - `階級値による平均値`) %>% \n  df_print()"
  },
  {
    "objectID": "chapter03.html#データの散らばりやバラツキを知りたい",
    "href": "chapter03.html#データの散らばりやバラツキを知りたい",
    "title": "\n3  データの散らばり具合を見積もる統計量\n",
    "section": "\n3.1 データの散らばりやバラツキを知りたい",
    "text": "3.1 データの散らばりやバラツキを知りたい\n　第2講で学んだ平均値（算術平均）は、データを代表する統計量で、ある一点（支点・重心）を示しているに過ぎません。データが平均値の周辺にどのように分布しているかはヒストグラムを使うことで視覚的には確認できますが、統計量として数値的に扱えた方がなにかと便利なはずです。"
  },
  {
    "objectID": "chapter03.html#バスの到着時刻の例で分散を理解する",
    "href": "chapter03.html#バスの到着時刻の例で分散を理解する",
    "title": "\n3  データの散らばり具合を見積もる統計量\n",
    "section": "\n3.2 バスの到着時刻の例で分散を理解する",
    "text": "3.2 バスの到着時刻の例で分散を理解する\n　蛇足ですが実際の路線バスでは予定時刻より早く到着しないように調整運転がなされていますので、時刻より大幅に早着することは稀です。\n\nベクトルを読み込みたい場合はscan()関数を使いますx <- scan(file = \"./data/P36_図表3-1.csv\", sep = \",\")\n\nx\n\n[1] 32 27 29 34 33\n\n\n　平均値を求めるmean()関数がありますが、ここでは平均値の計算式通りの計算を行っています。\n\n平均値を求める平均値 <- sum(x) / length(x)\n平均値\n\n[1] 31\n\n\n\n偏差を求める偏差 = x - 平均値\n偏差\n\n[1]  1 -4 -2  3  2\n\n\n　偏差の総和は必ずゼロ（\\(0\\)）になります。\n\n偏差の総和を求めるsum(偏差)\n\n[1] 0\n\n\n　偏差の二乗和をデータの個数で割ったものは、（標本）分散と呼ばれます。不偏分散と呼ばれる分散は計算式が異なります。Rで分散を計算するvar()関数は不偏分散を求める関数です。\n\n（標本）分散を求めるsum(偏差 ^ 2) / length(x)\n\n[1] 6.8\n\n\n\n\nvar()関数は不偏分散var(x)\n\n[1] 8.5\n\n　偏差の二乗平均値（\\(= \\sqrt{\\mbox{分散}}\\)）は標準偏差と呼ばれます。Rで標準偏差を計算するsd()関数は不偏分散のルートを取ったものです。\n\n（標本）標準偏差を求めるsqrt(sum(偏差 ^ 2) / length(x))\n\n[1] 2.607681\n\n\n\n\nsd()関数は標準偏差sd(x)\n\n[1] 2.915476"
  },
  {
    "objectID": "chapter03.html#標準偏差の意味",
    "href": "chapter03.html#標準偏差の意味",
    "title": "\n3  データの散らばり具合を見積もる統計量\n",
    "section": "\n3.3 標準偏差の意味",
    "text": "3.3 標準偏差の意味\n\n対象データx <- read.csv(file = \"./data/P39_図表3-4.csv\") \n\nx %>% \n  df_print()\n\n\n\n  \n\n\n\n\n各々の平均値を求めるmean <- x %>% \n  dplyr::summarise(X平均値 = mean(X), Y平均値 = mean(Y))\n\nmean %>% \n  df_print()\n\n\n\n  \n\n\n\n\n各々の偏差を求めるx %>% \n  dplyr::mutate(X偏差 = X - mean$X平均値,\n                Y偏差 = Y - mean$Y平均値) %>% \n  df_print()\n\n\n\n  \n\n\n\n\n各々の標準偏差を求めるx %>% \n  dplyr::mutate(X偏差 = X - mean$X平均値,\n                Y偏差 = Y - mean$Y平均値) %>% \n  dplyr::summarise(X標準偏差 = sqrt(sum(X偏差 ^ 2) / length(X)),\n                   Y標準偏差 = sqrt(sum(Y偏差 ^ 2) / length(Y))) %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n　偏差と標準偏差を可視化すると下図のようになり、XよりYの方が広範囲に分布していることが分かります。\n\n偏差と標準偏差を可視化するx %>% \n  dplyr::mutate(X偏差 = X - mean$X平均値,\n                Y偏差 = Y - mean$Y平均値) %>% \n  dplyr::select(-X, -Y) %>% \n  stripchart(xlim = c(-5, 5))\nabline(v = c(-0.89, 0.89), lty = 3)  # X標準偏差／ドット（点線）\nabline(v = c(-3.03, 3.03), lty = 2)  # Y標準偏差／ダッシュ（鎖線）"
  },
  {
    "objectID": "chapter03.html#度数分布表から標準偏差を求める",
    "href": "chapter03.html#度数分布表から標準偏差を求める",
    "title": "\n3  データの散らばり具合を見積もる統計量\n",
    "section": "\n3.4 度数分布表から標準偏差を求める",
    "text": "3.4 度数分布表から標準偏差を求める\n\n対象データx <- read.csv(file = \"./data/P40_図表3-6.csv\",\n              fileEncoding = \"UTF-8\")\n\nx %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n　第2講の「2−3 度数分布表での平均値」で学んだように度数分布表から平均値（の近似値）は \\[\\mbox{平均値} \\fallingdotseq \\sum{(\\mbox{階級値} \\times \\mbox{相対度数})}\\] 　で求めることができます。\n\n度数分布表から平均値を求めるx %>% \n  dplyr::mutate(AxB = A階級値 * B相対度数) %>% \n  df_print()\n\n\n\n  \n\n\n\n\n度数分布表から平均値を求める平均値 <- x %>% \n  dplyr::mutate(AxB = A階級値 * B相対度数) %>% \n  dplyr::summarize(平均値 = sum(AxB)) %>% \n  dplyr::pull(平均値)\n平均値\n\n[1] 2\n\n\n　\n　平均値を求められたので \\[\\mbox{階級の偏差（C階級値-平均値）} = \\mbox{階級値} - \\mbox{平均値}\\] 　とすると度数分布表の計算値と同じ考え方を適用し \\[\\mbox{階級の偏差の二乗平均} = \\sum{(\\mbox{階級の偏差}^2 \\times \\mbox{相対度数})} = \\mbox{分散}\\] 　となります。\n\n度数分布表から分散と階級偏差を求めるx %>% \n  dplyr::mutate(C = A階級値 - 平均値) %>% \n  dplyr::mutate(`C^2` = C ^ 2) %>% \n  dplyr::mutate(`C^2xB` = `C^2` * B相対度数) %>% \n  dplyr::select(A階級値, `C階級値-平均値` = C,\n                `C^2`, B相対度数, `C^2xB`) %>% \n  df_print()\n\n\n\n  \n\n\n\n\n度数分布表から分散と階級偏差を求めるx %>% \n  dplyr::mutate(`C` = `A階級値` - `平均値`) %>% \n  dplyr::mutate(`C^2` = `C` ^ 2) %>% \n  dplyr::mutate(`C^2xB` = `C^2` * `B相対度数`) %>% \n  dplyr::select(`A階級値`, `C階級値-平均値` = `C`,\n                `C^2`, `B相対度数`, `C^2xB`) %>% \n  dplyr::summarise(`分散` = sum(`C^2xB`)) %>% \n  dplyr::mutate(`標準偏差` = sqrt(`分散`)) %>% \n  df_print()"
  },
  {
    "objectID": "chapter03.html#練習問題",
    "href": "chapter03.html#練習問題",
    "title": "\n3  データの散らばり具合を見積もる統計量\n",
    "section": "練習問題",
    "text": "練習問題\n　次の架空のデータの標準偏差を次のステップで計算してみよ。ステップの記載は省略します。\n\n対象データデータ <- scan(file = \"./data/P42_練習問題_v.csv\", sep = \",\")\n\nデータ\n\n [1] 6 4 6 6 6 3 7 2 2 8\n\n\n解答例\n\n平均値を求める平均値 <- sum(データ) / length(データ)\n平均値\n\n[1] 5\n\n\n\n偏差を求める偏差 <- データ - 平均値\n偏差\n\n [1]  1 -1  1  1  1 -2  2 -3 -3  3\n\n\n\n二乗偏差を求める二乗偏差 <- 偏差 ^ 2\n二乗偏差\n\n [1] 1 1 1 1 1 4 4 9 9 9\n\n\n\n分散を求める分散 <- sum(二乗偏差) / length(二乗偏差)\n分散\n\n[1] 4\n\n\n\n標準偏差を求める標準偏差 <- sqrt(分散)\n標準偏差\n\n[1] 2"
  },
  {
    "objectID": "chapter03.html#追加問題",
    "href": "chapter03.html#追加問題",
    "title": "\n3  データの散らばり具合を見積もる統計量\n",
    "section": "追加問題",
    "text": "追加問題\n　P16にある身長データの度数分布表を作り、分散と標準偏差を求めてみましょう。\n\n\n\n\n  \n\n\n\n　\n解答例\n度数分布表から平均・分散・標準偏差を求める\n\n度数分布表から平均値を求めるx %>% \n  dplyr::mutate(AxB = A階級値 * B相対度数) %>% \n  df_print()\n\n\n\n  \n\n\n度数分布表から平均値を求める平均値 <- x %>% \n  dplyr::mutate(AxB = A階級値 * B相対度数) %>% \n  dplyr::summarise(平均値 = sum(AxB)) %>% \n  dplyr::pull(平均値)\n平均値\n\n[1] 157.75\n\n\n\n度数分布表から分散と標準偏差を求めるx %>% \n  dplyr::mutate(C = A階級値 - 平均値) %>% \n  dplyr::mutate(`C^2` = C ^ 2) %>% \n  dplyr::mutate(`C^2xB` = `C^2` * B相対度数) %>% \n  df_print()\n\n\n\n  \n\n\n\n\n度数分布表から分散と標準偏差を求めるfreq_summary <- x %>% \n  dplyr::mutate(C = A階級値 - 平均値) %>% \n  dplyr::mutate(`C^2` = C ^ 2) %>% \n  dplyr::mutate(`C^2xB` = `C^2` * B相対度数) %>% \n  dplyr::summarise(平均 = sum(A階級値 * B相対度数),\n                   分散 = sum(`C^2xB`)) %>% \n  dplyr::mutate(標準偏差 = sqrt(分散))\n\nfreq_summary %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n生データから平均・分散・標準偏差を求める\n\n生データから平均・分散・標準偏差を求める\"./data/P16_図表1-1 .csv\" %>% \n  readr::read_csv(col_names = FALSE,\n                  show_col_types = FALSE) %>% \n  tidyr::pivot_longer(cols = dplyr::starts_with(\"X\"),\n                      names_to = \"name\",\n                      values_to = \"value\") %>% \n  dplyr::arrange(name) %>% \n  dplyr::select(height = value) %>% \n  dplyr::mutate(偏差 = height - mean(height)) %>% \n  dplyr::mutate(二乗偏差 = 偏差 ^ 2) %>% \n  df_print()\n\n\n\n  \n\n\n\n\n生データから平均・分散・標準偏差を求めるraw_summary <- \"./data/P16_図表1-1 .csv\" %>% \n  readr::read_csv(col_names = FALSE,\n                  show_col_types = FALSE) %>% \n  tidyr::pivot_longer(cols = dplyr::starts_with(\"X\"),\n                      names_to = \"name\",\n                      values_to = \"value\") %>% \n  dplyr::arrange(name) %>% \n  dplyr::select(height = value) %>% \n  dplyr::mutate(偏差 = height - mean(height)) %>% \n  dplyr::mutate(二乗偏差 = 偏差 ^ 2) %>% \n  dplyr::summarise(平均 = sum(height) / length(height),\n                   分散 = sum(二乗偏差) / length(height),\n                   標準偏差 = sqrt(分散))\n\nraw_summary %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n度数分布表と生データの平均・分散・標準偏差を比較する\n\n度数分布表からの要約統計量freq_summary %>% \n  df_print()\n\n\n\n  \n\n\n\n\n生データからの要約統計量raw_summary %>% \n  df_print()\n\n\n\n  \n\n\n\n\n度数分布表と生データの差(freq_summary - raw_summary) %>% \n  df_print()"
  },
  {
    "objectID": "chapter04.html#標準偏差は波の激しさ",
    "href": "chapter04.html#標準偏差は波の激しさ",
    "title": "\n4  そのデータは「月並み」か「特殊」か？ 標準偏差で評価する\n",
    "section": "\n4.1 標準偏差は波の「激しさ」",
    "text": "4.1 標準偏差は波の「激しさ」\n　標準偏差は平均値からどの程度データがばらついているかを表しています。テキストではこのばらつきを「波打ちの激しさ」と表現しています。"
  },
  {
    "objectID": "chapter04.html#標準偏差がわかるとデータの特殊性を評価できる",
    "href": "chapter04.html#標準偏差がわかるとデータの特殊性を評価できる",
    "title": "\n4  そのデータは「月並み」か「特殊」か？ 標準偏差で評価する\n",
    "section": "\n4.2 標準偏差がわかるとデータの特殊性を評価できる",
    "text": "4.2 標準偏差がわかるとデータの特殊性を評価できる\n　標準偏差がわかるということは、以下がわかるということになります。\n\n一つのデータ（セット）の中にある任意の値の持つ意味\n複数のデータ（セット）の違い"
  },
  {
    "objectID": "chapter04.html#複数のデータセットの比較",
    "href": "chapter04.html#複数のデータセットの比較",
    "title": "\n4  そのデータは「月並み」か「特殊」か？ 標準偏差で評価する\n",
    "section": "\n4.3 複数のデータセットの比較",
    "text": "4.3 複数のデータセットの比較\n　（省略）"
  },
  {
    "objectID": "chapter04.html#加工されたデータの平均値と標準偏差",
    "href": "chapter04.html#加工されたデータの平均値と標準偏差",
    "title": "\n4  そのデータは「月並み」か「特殊」か？ 標準偏差で評価する\n",
    "section": "\n4.4 加工されたデータの平均値と標準偏差",
    "text": "4.4 加工されたデータの平均値と標準偏差\n　以下のデータに一定の加工を加えた際に平均値や標準偏差がどのように変化するかを見てみましょう。\n\n対象データx <- read.csv(file = \"./data/P49_図表4-5.csv\")\n\nx %>% \n  df_print()\n\n\n\n  \n\n\n\n　\nデータに一定数を加えた場合\n　それぞれに\\(4\\)を加える。\n\n元データ全てに\\(4\\)を加えるx %>% \n  dplyr::mutate(Y = X + 4) %>% \n  df_print()\n\n\n\n  \n\n\n\n\nそれぞれの平均値を求めるmean <- x %>% \n  dplyr::mutate(Y = X + 4) %>% \n  dplyr::summarise(X = mean(X), Y = mean(Y))\n\nmean %>% \n  df_print()\n\n\n\n  \n\n\n\n\n求めた平均値を用いてそれぞれの偏差を求めるdev <- x %>% \n  dplyr::mutate(Y = X + 4) %>% \n  dplyr::mutate(X = X - mean$X, Y = Y - mean$Y)\n\ndev %>% \n  df_print()\n\n\n\n  \n\n\n\n\n求めた偏差を用いてそれぞれの分散を求めるvar <- dev %>% \n  dplyr::summarize(X = sum(X ^ 2) / length(X),\n                   Y = sum(Y ^ 2) / length(Y))\n\nvar %>% \n  df_print()\n\n\n\n  \n\n\n\n\n求めた分散を用いてそれぞれの標準偏差を求めるsqrt(var) %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n　以上のようにデータに一定数を加えると平均値は加えた一定値の分だけ大きくなりますが、他の統計量は変化していないことが分かります。元データが正規分布のデータであると仮定して可視化すると下図のようになります。\n\n元データ（点線：左）と加算データ（破線：右）curve(dnorm(x, mean = 4, sd = 2), -3, 15, lty = 3, xlab = \"\", ylab = \"\")\nabline(v = 4, lty = 3)\ncurve(dnorm(x, mean = 8, sd = 2), -3, 15, add = TRUE, lty = 2, xlab = \"\", ylab = \"\")\nabline(v = 8, lty = 2)\n\n\n\n\n　\nデータに一定数を乗じた場合\n　それぞれに\\(2\\)を乗ずる。\n\n元データ全てに\\(2\\)を乗ずるx %>% \n  dplyr::mutate(Y = X * 2) %>% \n  df_print()\n\n\n\n  \n\n\n\n\nそれぞれの平均値を求めるmean <- x %>% \n  dplyr::mutate(Y = X * 2) %>% \n  dplyr::summarise(X = mean(X), Y = mean(Y))\n\nmean %>% \n  df_print()\n\n\n\n  \n\n\n\n\n求めた平均値を用いてそれぞれの偏差を求めるdev <- x %>% \n  dplyr::mutate(Y = X * 2) %>% \n  dplyr::mutate(X = X - mean$X, Y = Y - mean$Y)\n\ndev %>% \n  df_print()\n\n\n\n  \n\n\n\n\n求めた偏差を用いてそれぞれの分散を求めるvar <- dev %>% \n  dplyr::summarize(X = sum(X ^ 2) / length(X),\n                   Y = sum(Y ^ 2) / length(Y))\n\nvar %>% \n  df_print()\n\n\n\n  \n\n\n\n\n求めた分散を用いてそれぞれの標準偏差を求めるsqrt(var) %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n　以上のようにデータに一定数を乗じると平均値は乗じた一定値の分だけ大きくなり、他の統計量も乗じた一定値の分だけ大きくなっていることが分かります。元データが正規分布のデータであると仮定して可視化すると下図のようになります。\n\n元データ（点線：左）と加算データ（破線：右）curve(dnorm(x, mean = 4, sd = 2), -3, 15, lty = 3, xlab = \"\", ylab = \"\")\nabline(v = 4, lty = 3)\ncurve(dnorm(x, mean = 8, sd = 4), -3, 15, add = TRUE, lty = 2, xlab = \"\", ylab = \"\")\nabline(v = 8, lty = 2)\n\n\n\n\n　\n　整理すると下表になります。\n\n\n\n\n\n\n\n\n加工方法\n平均値\n標準偏差\n備考\n\n\n\n無加工（元データ\\(x\\)）\n\\(\\bar{x}\\)\n\\(SD\\)\n\n\n\n定数の加算(\\(x + k\\))\n\\(\\bar{x} + k\\)\n\\(SD\\)\n変化するのは平均値のみ\n\n\n定数の乗算(\\(x \\times k\\))\n\\(\\bar{x} \\times k\\)\n\\(SD \\times k\\)\n平均値・標準偏差ともに変化\n\n\n\n\\(k\\): 任意の実数\n　\n標準偏差何個分となるようにデータを加工する効果\n　ここで説明されているのは「正規化」です。\n\n対象データ（P49のデータX）x <- read.csv(file = \"./data/P49_図表4-5.csv\")\n\nx %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n　上記のP49のデータは、平均値\\(4\\)、標準偏差\\(2\\)ですので、\\((データ - 平均値) \\div 標準偏差\\)を計算（正規化）すると下記のようになります。\n\n正規化するx %>% \n  dplyr::mutate(dev = (X - (sum(X) / length(X))),\n                nX = dev / sqrt(sum(dev ^ 2) / length(dev))) %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n　nXの平均値と標準偏差は以下のように\\(0\\)と\\(1\\)になることが分かります。\n\n正規化したデータの平均と標準偏差を求めるx %>% \n  dplyr::mutate(nX = (X - 4) / 2) %>% \n  dplyr::summarise(mean = sum(nX) / length(nX),\n                   sd = sqrt(sum((nX - mean) ^ 2) / length(nX))) %>% \n  df_print()"
  },
  {
    "objectID": "chapter04.html#練習問題",
    "href": "chapter04.html#練習問題",
    "title": "\n4  そのデータは「月並み」か「特殊」か？ 標準偏差で評価する\n",
    "section": "練習問題",
    "text": "練習問題\n　（省略）"
  },
  {
    "objectID": "chapter04.html#コラム偏差値で嫌な思いをしたことのあるあなたに",
    "href": "chapter04.html#コラム偏差値で嫌な思いをしたことのあるあなたに",
    "title": "\n4  そのデータは「月並み」か「特殊」か？ 標準偏差で評価する\n",
    "section": "【コラム】偏差値で嫌な思いをしたことのあるあなたに",
    "text": "【コラム】偏差値で嫌な思いをしたことのあるあなたに\n　（省略）"
  },
  {
    "objectID": "chapter04.html#追加問題",
    "href": "chapter04.html#追加問題",
    "title": "\n4  そのデータは「月並み」か「特殊」か？ 標準偏差で評価する\n",
    "section": "追加問題",
    "text": "追加問題\n　P16の身長データを正規化（\\((\\mbox{データ} - \\mbox{平均値}) \\div \\mbox{標準偏差}\\)）してみましょう。\n　\n解答例\n\nscale()関数を使うと簡単に正規化できますx <- \"./data/P16_図表1-1 .csv\" %>% \n  readr::read_csv(col_names = FALSE, show_col_types = FALSE) %>% \n  tidyr::pivot_longer(cols = dplyr::starts_with(\"X\"),\n                      names_to = \"name\", values_to = \"value\") %>% \n  dplyr::arrange(name) %>% \n  dplyr::select(height = value) %>% \n  dplyr::mutate(normalized = scale(height))\n\nx %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n　正規化前後の平均値と標準偏差を比べると下記のようになります。\n\n正規化前の平均値と標準偏差x %>% \n  dplyr::summarise(mean = sum(height) / length(height),\n                   sd = sqrt(sum((height - mean)^ 2) / length(height))) %>% \n  df_print()\n\n\n\n  \n\n\n\n\n正規化後の平均値と標準偏差x %>% \n  dplyr::summarise(mean = sum(normalized) / length(normalized),\n                   sd = sqrt(sum((normalized - mean)^ 2) / length(normalized))) %>% \n  df_print()"
  },
  {
    "objectID": "chapter05.html#株の平均収益率とは何か",
    "href": "chapter05.html#株の平均収益率とは何か",
    "title": "\n5  標準偏差は株のリスクの指標として活用できる\n",
    "section": "\n5.1 株の平均収益率とは何か？",
    "text": "5.1 株の平均収益率とは何か？\n　株価の変動を利用して得られる収益は「キャピタルゲイン」と呼ばれます。キャピタルゲインを目当てとした株取引で重要になる指標のひとつに「収益率」があります。毎月の終値が前月の終値に対して、値上がった、または、値下がった率を「月次収益率」といいます。「月次平均収益率」は、月次収益率の一年間（十二ヶ月）単位で平均した値になります。"
  },
  {
    "objectID": "chapter05.html#平均収益率だけでは優良な投資かどうかは判断できない",
    "href": "chapter05.html#平均収益率だけでは優良な投資かどうかは判断できない",
    "title": "\n5  標準偏差は株のリスクの指標として活用できる\n",
    "section": "\n5.2 平均収益率だけでは、優良な投資かどうかは判断できない",
    "text": "5.2 平均収益率だけでは、優良な投資かどうかは判断できない\n　1980年台の株価の月次収益率です。年数の頭にXがついているのは、Rでは変数名は英数字から始まらなければならないからです。\n\n図表5-3 株の月次平均収益率\"./data/P56_ 図表5-3.csv\" %>% \n  read.csv() %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n　図表5-2は株の月次平均収益率ですので、図表5-3の株の月次収益率から簡単に計算することができます。\n\n図表5-2 株の月次平均収益率\"./data/P56_ 図表5-3.csv\" %>% \n  read.csv() %>% \n  dplyr::summarise_if(is.numeric, mean) %>% \n  round(digits = 2) %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n　同様に図表5-4の標準偏差（S.D）も図表5-3から求めることができます。\n\n図表5-3 月次平均収益率の標準偏差\"./data/P56_ 図表5-3.csv\" %>% \n  read.csv() %>% \n  dplyr::summarise_if(is.numeric, SD) %>% \n  round(digits = 2) %>% \n  df_print()\n\n\n\n  \n\n\n\n　\nこの二つの統計量（平均値、標準偏差）から月次の収益率はどの程度の範囲になるのかを可視化したものが下図です。テキストのように1981年の月次収益率は\\(2.46 \\pm 9.11\\%\\)の範囲になることは普通に考えるべきというのが分かります。\n::: {.cell code^fold=‘true’}\n月次平均収益率と標準偏差を可視化する\"./data/P56_ 図表5-3.csv\" %>% \n  read.csv() %>% \n  tidyr::pivot_longer(-月, names_to = \"年\", values_to = \"月次収益率\") %>% \n  dplyr::group_by(年) %>% \n  dplyr::summarise(月次平均収益率 = mean(月次収益率),\n                   標準偏差 = SD(月次収益率)) %>% \n  ggplot2::ggplot(ggplot2::aes(x = 年, y = 月次平均収益率)) + \n    ggplot2::geom_bar(stat = \"identity\", position = \"dodge\") + \n    ggplot2::geom_errorbar(ggplot2::aes(ymax = 月次平均収益率 + 標準偏差,\n                                        ymin = 月次平均収益率 - 標準偏差),\n                           position = \"dodge\", width = 0.2)\n\n\n\n:::"
  },
  {
    "objectID": "chapter05.html#ボラリティが意味するところ",
    "href": "chapter05.html#ボラリティが意味するところ",
    "title": "\n5  標準偏差は株のリスクの指標として活用できる\n",
    "section": "\n5.3 ボラリティが意味するところ",
    "text": "5.3 ボラリティが意味するところ\n　ボラリティ（予想変動率）とは標準偏差、つまり平均値からのブレ（バラツキ）のことです。例えば1981年の月次平均収益率は\\(2.46\\%\\)、標準偏差は\\(9.11\\%\\)なので、概ね下図のマゼンタ色のラインの間で変動していると想定できます。\n\n1981年の月次収益率\"./data/P56_ 図表5-3.csv\" %>% \n  read.csv() %>% \n  dplyr::mutate(月 = forcats::fct_inorder(月)) %>% \n  ggplot2::ggplot(ggplot2::aes(x = 月, y = X1981年)) + \n    ggplot2::geom_bar(stat = \"identity\") + \n    ggplot2::geom_hline(yintercept = 2.46, colour = \"lightskyblue\") + \n    ggplot2::geom_hline(yintercept = c(2.46 + 9.11, 2.46 - 9.11),\n                        colour = \"magenta\")"
  },
  {
    "objectID": "chapter05.html#練習問題",
    "href": "chapter05.html#練習問題",
    "title": "\n5  標準偏差は株のリスクの指標として活用できる\n",
    "section": "練習問題",
    "text": "練習問題\n　（省略）"
  },
  {
    "objectID": "chapter05.html#実際の株価で計算してみる",
    "href": "chapter05.html#実際の株価で計算してみる",
    "title": "\n5  標準偏差は株のリスクの指標として活用できる\n",
    "section": "実際の株価で計算してみる",
    "text": "実際の株価で計算してみる\n　実際に株探というサイトから某社の月次株価一覧を取得して月次平均収益率を計算してみます。\n\nサイトから取得した株価データstock <- \"./data/sample/株価の月次推移_2022-06-15.csv\" %>% \n  read_csv()\nstock %>% df_print()\n\n\n\n  \n\n\n\n　\n　月次収益率の十二ヶ月平均が月次平均収益率になりますので、データがそろっている年の月次平均収益率と標準偏差を算出します。\n\n月次平均収益率と標準偏差を求めるstock %>% \n  dplyr::mutate(年 = lubridate::year(日付)) %>% \n  dplyr::filter(年 >= 2010 & 年 <= 2021) %>% \n  dplyr::group_by(年) %>% \n  dplyr::summarise(月次平均収益率 = mean(月次収益率),\n                   標準偏差 = SD(月次収益率)) %>% \n  round(digits = 2) %>% \n  df_print()\n\n\n\n  \n\n\n\n　\n　上記を可視化します。\n\n月次平均収益率と標準偏差を可視化するstock %>% \n  dplyr::mutate(年 = lubridate::year(日付)) %>% \n  dplyr::filter(年 >= 2010 & 年 <= 2021) %>% \n  dplyr::group_by(年) %>% \n  dplyr::summarise(月次平均収益率 = mean(as.numeric(月次収益率)) %>% \n                            round(digits = 2),\n                   標準偏差 = SD(月次収益率)) %>% \n  ggplot2::ggplot(ggplot2::aes(x = 年, y = 月次平均収益率)) + \n    ggplot2::geom_bar(stat = \"identity\", position = \"dodge\") + \n    ggplot2::geom_errorbar(ggplot2::aes(ymax = 月次平均収益率 + 標準偏差,\n                                        ymin = 月次平均収益率 - 標準偏差),\n                           position = \"dodge\", width = 0.2)\n\n\n\n\n　\n　月次平均収益率だけを見ていても儲けられる株かどうかの判断が難しいので、参考までに隔月の終値の変動を可視化します。\n\n終値の変動を可視化するstock %>% \n  ggplot2::ggplot(ggplot2::aes(x = 日付, y = 終値)) + \n    ggplot2::geom_line()\n\n\n\n\n\n直近三年の月次収益率の変動を可視化するstock %>% \n  dplyr::mutate(年 = lubridate::year(日付), 月 = lubridate::month(日付)) %>% \n  dplyr::filter(年 >= 2019 & 年 <= 2021) %>% \n  dplyr::mutate(年 = as.factor(年)) %>% \n  ggplot2::ggplot(ggplot2::aes(x = 月, y = 月次収益率, fill = 年)) +\n    ggplot2::geom_bar(stat = \"identity\", position = \"dodge\")\n\n\n\n\n　\n\n5.3.1 複数の株を比較する\n　複数の同業種銘柄を比較してみます。どの株が儲かりそうでしょうか？\n\n6銘柄の月次平均収益率と標準偏差を可視化する（改良板）stock_n <- \"./data/sample/６銘柄の株価の月次推移_2022-06-15.csv\" %>% \n  read_csv()\n\nstock_n %>% df_print()\n\n\n\n  \n\n\n6銘柄の月次平均収益率と標準偏差を可視化する（改良板）stock_n %>% \n  dplyr::mutate(dplyr::across(.cols = tidyselect::starts_with(\"X\"),\n                              .fns = readr::parse_guess)) %>% \n  dplyr::mutate(date = lubridate::as_date(日付),\n                year = lubridate::year(date),\n                code = as.character(code)) %>% \n  dplyr::filter(year >= 2010 & year <= 2021) %>% \n  dplyr::group_by(code, year) %>% \n  dplyr::summarise(mean = mean(`前月比％`), sd = sd(`前月比％`)) %>% \n  # print() %>% \n  ggplot2::ggplot(ggplot2::aes(x = year, y = mean, fill = code)) + \n    ggplot2::geom_bar(stat = \"identity\", position = \"dodge\") + \n    ggplot2::geom_errorbar(ggplot2::aes(ymax = mean + sd,\n                                        ymin = mean - sd),\n                           position = \"dodge\", width = 0.5, size = 0.25) + \n    ggplot2::facet_wrap(~ code)"
  },
  {
    "objectID": "chapter06.html#ハイリスクハイリターンとローリスクローリターン",
    "href": "chapter06.html#ハイリスクハイリターンとローリスクローリターン",
    "title": "\n6  標準偏差でハイリスク・ハイリターンも理解できる\n",
    "section": "\n6.1 ハイリスク・ハイリターンとローリスク・ローリターン",
    "text": "6.1 ハイリスク・ハイリターンとローリスク・ローリターン\n　ボラティリティとは株の収益率の標準偏差（SD）のことで、収益率は標準偏差分の変動（\\(\\pm SD\\)）が起きるので、それをリスクとして認識すべきです。\n\nP60図表6−1\"./data/P60_図表6-1.csv\" %>% \n  read.csv() %>% \n  df_print()\n\n\n\n  \n\n\n\n　各金融商品の標準偏差（リスク）と平均値（リターン）は下表のようになります。このデータでの標準偏差（リスク）は標本標準偏差ではないことに注意してください。\n\nP60図表6−1のリスクとリターンリスク <- \"./data/P60_図表6-1.csv\" %>%\n  read.csv() %>%\n  dplyr::summarise(dplyr::across(.cols = tidyselect::starts_with(\"商品\"),\n                                 .fns = sd)) %>%\n  round(digits = 1)\n\nリスク %>% \n  df_print()\n\n\n\n  \n\n\nP60図表6−1のリスクとリターンリターン <- \"./data/P60_図表6-1.csv\" %>%\n  read.csv() %>%\n  dplyr::summarise(dplyr::across(.cols = tidyselect::starts_with(\"商品\"),\n                                 .fns = mean)) %>%\n  round(digits = 1)\n\nリターン %>% \n  df_print()\n\n\n\n  \n\n\n\n　このようにリターンの大きな商品はリスクも大きい、ハイリスク・ハイリターンであることが分かります。\n\nリスクとリターンの関係risk <- リスク %>%\n  tidyr::pivot_longer(cols = dplyr::everything(),\n                      names_to = \"商品\", values_to = \"リスク\")\n\nreturn <- リターン %>%\n  tidyr::pivot_longer(cols = dplyr::everything(),\n                      names_to = \"商品\", values_to = \"リターン\")\n\nrisk %>%\n  dplyr::left_join(return, by = \"商品\") %>%\n  ggplot2::ggplot(ggplot2::aes(x = リスク, y = リターン, label = 商品)) +\n    ggplot2::geom_point() +\n    ggplot2::geom_smooth(se = FALSE, method = \"lm\", size = 0.5) +\n    ggrepel::geom_text_repel() + \n    ggplot2::lims(x = c(0, 16), y = c(0, 16))"
  },
  {
    "objectID": "chapter06.html#金融商品の優劣の測り方",
    "href": "chapter06.html#金融商品の優劣の測り方",
    "title": "\n6  標準偏差でハイリスク・ハイリターンも理解できる\n",
    "section": "\n6.2 金融商品の優劣の測り方",
    "text": "6.2 金融商品の優劣の測り方\n　前述の商品A〜商品Dの四商品を比較する限り、優劣はありません。では、下図の商品N, P, Qは四商品（A〜D）と比べてどれが優れているのでしょうか？"
  },
  {
    "objectID": "chapter06.html#金融商品の優劣を測る数値シャープレシオ",
    "href": "chapter06.html#金融商品の優劣を測る数値シャープレシオ",
    "title": "\n6  標準偏差でハイリスク・ハイリターンも理解できる\n",
    "section": "\n6.3 金融商品の優劣を測る数値・シャープレシオ",
    "text": "6.3 金融商品の優劣を測る数値・シャープレシオ\n　シャープレシオは下式で定義される金融商品の優劣を比較するための指標です。シャープレシオが高いほどリスクを抑えながらリターンが期待できる効率的なファンドといえます。\n\\[\\mbox{シャープレシオ} = \\frac{\\mbox{リターンの平均値} - \\mbox{無リスク資産の利回り}}{\\mbox{リスク（リターンの標準偏差）}}\\]\n　無リスク資産の利回りには国債の利回りを使用する場合が多いようですが、具体的に何を用いているかを記載しているファンドを見たことがありません。参考までに近年の国債の利回りは下表の通りです。\n\n財務省の国債金利情報より\"https://www.mof.go.jp/jgbs/reference/interest_rate/jgbcm.csv\" %>% \n  readr::read_csv(locale = readr::locale(encoding = \"CP932\"), skip = 1) %>% \n  df_print()\n\n\n\n  \n\n\n\n　国債の利回りは5年経って約\\(0\\%\\)なので、無リスク資産の利回りを\\(0\\%\\)（利回りはほぼ得られない）と考えるとシャープレシオは下式のようになります。\n\\[\\mbox{シャープレシオ} = \\frac{\\mbox{リターンの平均値}}{\\mbox{リスク（リターンの標準偏差）}}\\]\n　リターンの平均値は、リスク（リターンの標準偏差）とシャープレシオが分かれば下式で求められます。\n\\[\\mbox{リターンの平均値} = \\mbox{リスク} \\times \\mbox{シャープレシオ} + \\mbox{無リスク資産の利回り}\\]"
  },
  {
    "objectID": "chapter06.html#練習問題",
    "href": "chapter06.html#練習問題",
    "title": "\n6  標準偏差でハイリスク・ハイリターンも理解できる\n",
    "section": "練習問題",
    "text": "練習問題\n　（省略）"
  },
  {
    "objectID": "chapter06.html#実際のデータで確認する",
    "href": "chapter06.html#実際のデータで確認する",
    "title": "\n6  標準偏差でハイリスク・ハイリターンも理解できる\n",
    "section": "実際のデータで確認する",
    "text": "実際のデータで確認する\n　実際のデータではテキストと同じ言葉でリターンとリスクが公開されているわけではありません。証券会社などにより様々な表現がなされていますので、最初に簡単に整理しておきます。\n　投資信託の基礎知識によれば\n　利回りとは\n\n投資金額に対する収益の割合のことをいいます。この収益には「利息」だけでなく、投資商品を売却した場合に得られる「売却損益」も含みます。また、通常は1年間の「年利回り」のことを利回りと呼ぶことが多いです。\n\n　利回りを数式で表すと下式になります。ただし、手数料や税金などは考慮していません。\n\\[\\mbox{利回り} = \\frac{\\mbox{分配金} + \\mbox{売却益}}{\\mbox{投資金額}} \\times 100\\]\n　参考までに利率は\n\n一般的に、利率は、債券や預金に対して使われる言葉のため、投資信託では利率とは言いません。\n\n　SMBC日興証券では「累積リターン」という言葉を使っていますが、その定義は以下となっていますので利回りと等価といえます。\n\n一定期間内における分配金込み基準価額の騰落率です。\n\n　一方、騰落率は\n\n騰落率とは、投資信託の基準価額が、ある期間の間にどのくらい変動したかを、パーセンテージで示します。例えば、基準価額10,000円の投資信託が1年後に11,000円に値上がりした場合の騰落率は10％です。\n\n　式では下式となります。ただし、利回りと同様に手数料や税金などは考慮していません。\n\\[\\mbox{騰落率} = \\frac{\\mbox{期末基準価額} - \\mbox{期首基準価額}}{\\mbox{期首基準価額}} \\times 100\\]\n　ただし、投信総合検索ライブラリーでは「騰落率」を以下のように定義しています。\n\n期間別騰落率は、分配金(課税前)をファンドへ再投資したものとみなして月末時点の修正した価額をもとに計算＊しています。一方、利回りは、分配金込み基準価額の騰落率です。\n\n　具体的には用語集に記載されているように下式の定義となります。\n\n(期末の基準価額+期中の分配金の合計)/期首の基準価額-1\n\n　この定義を整理すると下式になります。\n\\[\\frac{\\mbox{期末準価額} + \\mbox{期中分配金}}{\\mbox{期首基準価額}} - 1 = \\frac{\\mbox{期中分配金} + \\mbox{期末基準価額} - \\mbox{期首基準価額}}{\\mbox{期首基準価額}}\\]\n　期末で売却したとすると\\(\\mbox{期末基準価格} - \\mbox{期首基準価格} = \\mbox{売却益}\\)とみなせ、期首で投資したとすれば、\\(\\mbox{期首基準価格} = \\mbox{投資金額}\\)となり投信総合検索ライブラリーでの騰落率は「利回り」と同等であることが分かります。\n\\[\\frac{\\mbox{分配金} + \\mbox{売約益}}{\\mbox{期首基準価額}} = \\frac{\\mbox{分配金} + \\mbox{売約益}}{\\mbox{投資金額}}\\]\n　実際に同一銘柄を投信総合ライブラリーとSMBC日興証券で比較すると部分的に若干の差異が認められるものの騰落率と累積リターンが同一指標になっていることが分かります。\n　ただし、利回りや騰落率は一年間（期首と期末）の数値から求めていることに注意してください。リターンの平均値を知りたい場合は、騰落率ではなく前述したようにシャープレシオとリスク（標準偏差）から求める必要があります。近年の無リスク資産（国債）の利回りは、ほぼ\\(0\\%\\)なので、これは省略しています。\n\\[\\mbox{リターンの平均値} = \\mbox{シャープレシオ} \\times \\mbox{リスク}\\]\n　\n投信総合検索ライブラリー\n　楽天証券で扱っているつみたてNISAのファンドのデータを投信総合検索ライブラリーから取得して実際のデータがどのようになっているかをみます。 　\n　取得しているファンドは下表の通りです。\n\n商品種別ごとのファンド数\"./data/sample/つみたてNISA_基本情報_2022-06-12.csv\" %>%\n  read.csv() %>%\n  dplyr::group_by(インデックス型, type) %>%\n  dplyr::summarise(n = n()) %>%\n  tidyr::pivot_wider(names_from = インデックス型, values_from = n) %>% \n  df_print()\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n　\n　商品分類別のリスク・リターンの平均値（インデックス型での区別なし）は下図のようになります。\n\n商品分類別平均値\"./data/sample/つみたてNISA_商品分類別運用情報_2022-06-18.csv\" %>% \n  read.csv() %>% \n  dplyr::mutate(リターン = シャープレシオ * `リスク.標準偏差.`,\n                label = paste0(X2, \"/\", シャープレシオ)) %>% \n  dplyr::rename(リスク = `リスク.標準偏差.`, 商品分類 = type) %>% \n  ggplot2::ggplot(ggplot2::aes(x = リスク, y = リターン,\n                               colour = 商品分類, label = label)) + \n    ggplot2::geom_abline(slope = c(0, 1), intercept = 0,\n                         size = 0.2, linetype = \"dashed\") +\n    ggplot2::geom_point() +\n    ggplot2::geom_path(linetype = \"dotted\") + \n    ggrepel::geom_text_repel(size = 3.5) + \n    ggplot2::lims(x = c(0, 30), y = c(-15, 15)) +\n    ggplot2::labs(title = \"商品分類別の平均\",\n                  caption = \"※無リスク資産の利回りを0%とした場合\")\n\n\n\n\n　\n　国内外の問わず株式商品が資産複合商品に比べるとハイリスク・ハイリターンと言えます。また、どの商品も3年を超えると若干リスクが下がる傾向があるようです。\n　なお、投信総合検索ライブラリーのデータ上、資産複合は国内外の区別がありません。"
  },
  {
    "objectID": "chapter07.html#最もよく見かけるデータ分布",
    "href": "chapter07.html#最もよく見かけるデータ分布",
    "title": "\n7  身長、コイン投げなど最もよく見られる分布、正規分布\n",
    "section": "\n7.1 最もよく見かけるデータ分布",
    "text": "7.1 最もよく見かけるデータ分布\n\n図表7-1 標準正規分布のヒストグラム# 「密度×階級幅=相対度数」の関係を用いて密度関数から相対度数を求める\ndata <- tibble::tibble(x = seq(-2.5, 2.5, 0.1),\n                       y = dnorm(x) * 0.1) %>% \n  dplyr::mutate(y = dplyr::if_else(x == 0.0, y, 0))\n\ntibble::tibble(x = seq(-2.5, 2.5, 0.1),\n               y = dnorm(x) * 0.1) %>% \n  ggplot2::ggplot(ggplot2::aes(x = x, y = y)) + \n  ggplot2::geom_bar(stat = \"identity\",\n                    fill = \"lightblue3\", colour = \"lightblue4\") + \n  ggplot2::geom_bar(ggplot2::aes(x, y), data = data,\n                    stat = \"identity\", fill = \"gray30\") +\n  ggplot2::labs(x = \"\", y = \"相対度数\") + \n  ggplot2::scale_x_continuous(breaks = seq(-2.4, 2.4, 0.3)) + \n  ggplot2::scale_y_continuous(breaks = seq(0, 0.04, 0.005))"
  },
  {
    "objectID": "chapter07.html#一般の正規分布の眺め方",
    "href": "chapter07.html#一般の正規分布の眺め方",
    "title": "\n7  身長、コイン投げなど最もよく見られる分布、正規分布\n",
    "section": "\n7.2 一般の正規分布の眺め方",
    "text": "7.2 一般の正規分布の眺め方"
  },
  {
    "objectID": "chapter07.html#身長のデータは正規分布している",
    "href": "chapter07.html#身長のデータは正規分布している",
    "title": "\n7  身長、コイン投げなど最もよく見られる分布、正規分布\n",
    "section": "\n7.3 身長のデータは正規分布している",
    "text": "7.3 身長のデータは正規分布している"
  }
]