[["index.html", "Rで学ぶ『完全独習 統計学入門』 はじめに 想定読者", " Rで学ぶ『完全独習 統計学入門』 Sampo Suzuki, CC 4.0 BY-NC-SA 2022-05-18 はじめに 本資料は『完全独習 統計学入門』小島寛之著（以降、テキスト）の内容をRで計算する方法を紹介しています。基本的な統計量を求める際に必要となる関数などの解説が中心です。 テキストに記載されているデータの一部をCSVファイルにして利用していますが、データ自体の著作権は原著作者にあります。また、CSVファイルは著作権を侵害する意図で作成したものではありません。 想定読者 本書の想定読者は以下に該当する方です。 Rに関する基本的な知識を有している方 データフレーム型や因子型などの変数型の知識 変数の代入・参照方法 tidyverseの基本的な知識 Rで統計量を求めてみたい方 本書ではRのインストール方法や基本文法には触れません。 "],["度数分布表とヒストグラムでデータの特徴を浮き彫りにする.html", "第1講 度数分布表とヒストグラムでデータの特徴を浮き彫りにする 1.1 生データでは何もわからないから統計を使う 1.2 ヒストグラムを作る 1.3 練習問題 ヒストグラムを描くポイント 等間隔ではない階級", " 第1講 度数分布表とヒストグラムでデータの特徴を浮き彫りにする 1.1 生データでは何もわからないから統計を使う テキストの図表1-1のデータは4列20行からなるデータです。 Rでは、このような形式のデータ（雑然データ）をそのまま使わずに整然データ（Tidy Data）と呼ばれる形式に変換した方が効率的に処理できます。変換にはtidyverseファミリーを利用するのが効率的です。 library(tidyverse) # ローカルにあるデータファイルを読み込む x &lt;- &quot;../data/P16_図表1-1 .csv&quot; %&gt;% readr::read_csv(col_names = FALSE, show_col_types = FALSE) %&gt;% # 読み込んだデータを縦長形式（Tidy Data）に変換する tidyr::pivot_longer(cols = dplyr::starts_with(&quot;X&quot;), names_to = &quot;name&quot;, values_to = &quot;value&quot;) %&gt;% # X1, X2, ... , X4, X1 の順で行方向に読み込まれるので列方向で整列する dplyr::arrange(name) %&gt;% # 必要なデータ列（value）の列名をheightに変更して取り出す dplyr::select(height = value) x このような形式に変換することで、様々な統計量を効率的に求めることができるようになります。 1.2 ヒストグラムを作る テキストでは度数分布表を作成してからヒストグラムを描いています。その手順は 最大・最小値を求める 階級を決める 度数をカウントする 相対度数を求める 累積度数を求める ここまでで度数分布表ができる 度数分布表をもとにヒストグラムを描く となっていますが、Rではhist()関数だけでヒストグラムを描くことができます。hist()関数の引数はベクトル型に限定されますので、データフレーム型の場合は参照演算子（$）などでベクトル型データを取り出す必要があります。 hist(x = x$height) Fig. 1.1: Rのhist()関数 hist()関数はヒストグラムを描くために必要となる階級や度数、階級値などの情報を出力することも可能です。 hist(x = x$height, plot = FALSE) ## $breaks ## [1] 140 145 150 155 160 165 170 ## ## $counts ## [1] 1 6 19 30 18 6 ## ## $density ## [1] 0.0025 0.0150 0.0475 0.0750 0.0450 0.0150 ## ## $mids ## [1] 142.5 147.5 152.5 157.5 162.5 167.5 ## ## $xname ## [1] &quot;x$height&quot; ## ## $equidist ## [1] TRUE ## ## attr(,&quot;class&quot;) ## [1] &quot;histogram&quot; 主な出力の意味 出力名 意味 備考 $breaks 階級 デフォルトはスタージェスの公式*にもとづく区切り（幅） $counts 度数 各階級に入るデータの個数 $density 密度 密度推定値 $mids 階級値 階級の中央値（階級の単純平均） * 後述 表形式の度数分布表を作成する場合は以下のようにコード処理します。 x %&gt;% # 階級を求めて、データを階級ごとに分ける dplyr::mutate(class = cut(height, breaks = pretty(height, n = nclass.Sturges(height)), include.lowest = FALSE, right = TRUE)) %&gt;% # 階級ごとの度数を求める dplyr::count(class) %&gt;% # 累積度数、相対度数、累積相対度数を求める dplyr::mutate(cumsum_n = cumsum(n), prop = prop.table(n), cumsum_prop = cumsum(prop)) %&gt;% # 階級値を求める dplyr::mutate(class_value = as.character(class)) %&gt;% tidyr::separate(class_value, into = c(&quot;l&quot;, &quot;h&quot;), sep = &quot;,&quot;) %&gt;% dplyr::mutate(l = as.integer(stringr::str_remove(l, &quot;[[:punct:]]&quot;)) + 1L, h = as.integer(stringr::str_remove(h, &quot;[[:punct:]]&quot;)), mids = (l + h) / 2L) %&gt;% # 変数名を日本語にする dplyr::select(`階級` = class, `階級値` = mids, `度数` = n, `累積度数` = cumsum_n, `相対度数` = prop, `累積相対度数` = cumsum_prop) 以降の項は度数分布表の作成に必要な関数の使い方を紹介していますので、不要な方は演習問題まで読み飛ばしてください。 1.2.1 階級を求める 以降に出てくるwith()関数は、第一引数で指定するデータフレーム型変数内の変数名を第二引数内で参照演算子（$）を用いることなく参照できるようにする関数です。 階級を求めるにはpretty()関数を使います。 with(x, pretty(x = height, n = nclass.Sturges(height))) ## [1] 140 145 150 155 160 165 170 第一引数xには階級を求めたいベクトル型データを第二引数nには階級を区切りたい数（階級数）を指定します。ここでは、階級数nにはスタージェスの公式から求めた階級数を指定しています。 ただし、必ずしも指定した階級数に分割される訳ではない点に注意してください。xで指定したデータが階級に収まるように適切な丸め処理を行いますので、指定した階級数とは異なる階級が求められることもあります。 スタージェスの公式は、階級数を\\(k\\)、データのサイズ（数）を\\(n\\)とした場合、下式で定義されます。 \\[k = \\lceil \\log_2n + 1 \\rceil\\] スタージェスの公式はnclass.Sturgess()関数として実装されています。 with(x, nclass.Sturges(height)) ## [1] 8 スタージェスの公式はヒストグラムを平滑化し過ぎる傾向があると言われています。気になる場合はスコットの選択（nclass.scott()）やフリードマン=ダイアコニスの選択（nclass.FD()）を試して見てください。 1.2.2 データを各階級に分類する データを階級分けするにはcut()関数を使います。 with(x, cut(x = height, breaks = pretty(height, n = nclass.Sturges(height)))) ## [1] (150,155] (150,155] (155,160] (155,160] (160,165] (155,160] (155,160] ## [8] (155,160] (150,155] (155,160] (150,155] (160,165] (155,160] (160,165] ## [15] (155,160] (160,165] (160,165] (165,170] (145,150] (160,165] (150,155] ## [22] (160,165] (155,160] (160,165] (165,170] (150,155] (155,160] (150,155] ## [29] (155,160] (155,160] (155,160] (145,150] (160,165] (150,155] (155,160] ## [36] (160,165] (150,155] (160,165] (150,155] (150,155] (150,155] (150,155] ## [43] (155,160] (145,150] (145,150] (160,165] (165,170] (150,155] (150,155] ## [50] (165,170] (160,165] (160,165] (145,150] (140,145] (155,160] (160,165] ## [57] (155,160] (155,160] (155,160] (160,165] (165,170] (155,160] (155,160] ## [64] (150,155] (155,160] (155,160] (150,155] (155,160] (150,155] (155,160] ## [71] (145,150] (165,170] (150,155] (155,160] (155,160] (155,160] (160,165] ## [78] (155,160] (155,160] (160,165] ## Levels: (140,145] (145,150] (150,155] (155,160] (160,165] (165,170] 第一引数xには階級分けの対象となるベクトル型変数を第二引数breaksには前項で求めた階級を指定します。breaks引数には任意の階級、例えばbreaks = c(140, 155, 170)のように指定することも可能です。 階級の境界値はどちらに含まれるのか？ cut()関数の出力は、(140,145] (145,150]のように階級間で同じ数値、この場合は145が含まれます。では、145はどちらの階級に含まれるのでしょうか？答えは、添えられている括弧にあります。 (140,145] は「140を超えて145以下」となりますので、次の (145,150] は同様に「145を超えて150以下」となります。階級間の境界値である145は(140, 145]側に入ります。 (は「超えて」（境界値を含まない）、]は「以下」（境界値を含む） で、逆向きの場合は )は「未満」（境界値を含まない）、[は「以上」（境界値を含む） となります。hist()関数の階級も同様です。 境界値をどちらに含めるかはinclude.lowest引数とright引数で指定できます。 option right = TRUE right = FALSE include.lowest = TRUE [l,u] ... (l,u] [l,u) ... [l,u] include.lowest = FALSE (l,u] ... (l,u]* [l,u) ... [l,u) *デフォルト 例えばデータの最大値と最小値を境界値として含む階級を指定した場合、include.lowest = FALSE, right = FALSEと指定すると最大値が階級に含まれなくなります。 with(x, cut(height, breaks = c(143, 155, 169), include.lowest = FALSE, right = FALSE)) ## [1] [143,155) [143,155) [155,169) [155,169) [155,169) [155,169) [155,169) ## [8] [155,169) [143,155) [155,169) [143,155) [155,169) [155,169) [155,169) ## [15] [155,169) [155,169) [155,169) &lt;NA&gt; [143,155) [155,169) [143,155) ## [22] [155,169) [155,169) [155,169) [155,169) [143,155) [155,169) [155,169) ## [29] [155,169) [155,169) [155,169) [143,155) [155,169) [155,169) [155,169) ## [36] [155,169) [143,155) [155,169) [143,155) [143,155) [143,155) [155,169) ## [43] [155,169) [143,155) [143,155) [155,169) &lt;NA&gt; [143,155) [155,169) ## [50] [155,169) [155,169) [155,169) [143,155) [143,155) [155,169) [155,169) ## [57] [155,169) [155,169) [155,169) [155,169) [155,169) [155,169) [155,169) ## [64] [143,155) [155,169) [155,169) [143,155) [155,169) [143,155) [155,169) ## [71] [143,155) [155,169) [143,155) [155,169) [155,169) [155,169) [155,169) ## [78] [155,169) [155,169) [155,169) ## Levels: [143,155) [155,169) 逆にinclude.lowest = FALSE, right = TRUEと指定すると最小値が階級に含まれなくなります。 with(x, cut(height, breaks = c(143, 155, 169), include.lowest = FALSE, right = TRUE)) ## [1] (143,155] (143,155] (155,169] (155,169] (155,169] (155,169] (155,169] ## [8] (155,169] (143,155] (155,169] (143,155] (155,169] (155,169] (155,169] ## [15] (155,169] (155,169] (155,169] (155,169] (143,155] (155,169] (143,155] ## [22] (155,169] (155,169] (155,169] (155,169] (143,155] (155,169] (143,155] ## [29] (155,169] (155,169] (155,169] (143,155] (155,169] (143,155] (155,169] ## [36] (155,169] (143,155] (155,169] (143,155] (143,155] (143,155] (143,155] ## [43] (155,169] (143,155] (143,155] (155,169] (155,169] (143,155] (143,155] ## [50] (155,169] (155,169] (155,169] (143,155] &lt;NA&gt; (155,169] (155,169] ## [57] (155,169] (155,169] (155,169] (155,169] (155,169] (155,169] (155,169] ## [64] (143,155] (155,169] (155,169] (143,155] (155,169] (143,155] (155,169] ## [71] (143,155] (155,169] (143,155] (155,169] (155,169] (155,169] (155,169] ## [78] (155,169] (155,169] (155,169] ## Levels: (143,155] (155,169] 1.2.3 度数を求める 度数を求めるには各階級の数を数えます。数を数えるにはtable()関数やdplyr::count()関数を使います。table()関数はベクトル型を対象に、dplyr::count()関数はデータフレーム型を対象として個数をカウントします。用途によって使い分けてください。 with(x, table(cut(height, breaks = pretty(height, n = nclass.Sturges(height))))) ## ## (140,145] (145,150] (150,155] (155,160] (160,165] (165,170] ## 1 6 19 30 18 6 x %&gt;% # 階級を求めて、データを階級ごとに分ける dplyr::mutate(class = cut(height, breaks = pretty(height, n = nclass.Sturges(height)))) %&gt;% # 階級ごとの度数を求める dplyr::count(class) 1.2.4 累積度数、相対度数、累積相対度数を求める 累積度数（度数の累積和）を求めるにはcumsum()関数を使います。 with(x, cumsum(table(cut(height, breaks = pretty(height, n = nclass.Sturges(height)))))) ## (140,145] (145,150] (150,155] (155,160] (160,165] (165,170] ## 1 7 26 56 74 80 相対度数を求めるにはprop.table()関数を使います。 with(x, prop.table(table(cut(height, breaks = pretty(height, n = nclass.Sturges(height)))))) ## ## (140,145] (145,150] (150,155] (155,160] (160,165] (165,170] ## 0.0125 0.0750 0.2375 0.3750 0.2250 0.0750 累積相対度数は相対度数の累積和ですので、prop.table()関数の結果をcumsum()関数に渡すことで求めることができます。 with(x, cumsum(prop.table(table(cut(height, breaks = pretty(height, n = nclass.Sturges(height))))))) ## (140,145] (145,150] (150,155] (155,160] (160,165] (165,170] ## 0.0125 0.0875 0.3250 0.7000 0.9250 1.0000 1.2.5 階級値を求める 階級値は階級の文字列から下端と上端の境界値を抜き出し、下式で単純平均として求めています。 \\[\\frac{(\\mbox{下端} + 1) + \\mbox{上端}}{2}\\] 手順としては以下のようにしています。 as.character()関数で 階級（class）を文字型に変換し、新しい変数（class_value）を作成する tidyr::separate()関数で文字型の変数（class_value）を,の前後で二つの変数（l, h）に分割する stringr::str_remove関数で二つの変数（l, h）から(や]を取り除きas.numeric()関数で文字列から数値に変換する 数値に変換された二つの変数から（l, h）平均値を求める x %&gt;% # 階級を求めて、データを階級ごとに分ける dplyr::mutate(class = cut(height, breaks = pretty(height, n = nclass.Sturges(height)), include.lowest = FALSE, right = TRUE)) %&gt;% # 階級ごとの度数を求める dplyr::count(class) %&gt;% # 階級値を求める dplyr::mutate(class_value = as.character(class)) %&gt;% tidyr::separate(class_value, into = c(&quot;l&quot;, &quot;h&quot;), sep = &quot;,&quot;) %&gt;% dplyr::mutate(l = as.numeric(stringr::str_remove(l, &quot;[[:punct:]]&quot;)), h = as.numeric(stringr::str_remove(h, &quot;[[:punct:]]&quot;))) %&gt;% dplyr::mutate(mids = ((l + 1) + h) / 2) 1.3 練習問題 テキストP23にあるデータで度数分布表とヒストグラムを作成する。 解答例 まず、処理しやすいように下記のように対象データを変形しdfというデータフレーム型の変数に格納しておきます。 df 度数分布表を身長の場合と同じ要領で作成します。 df %&gt;% # 階級を求めて、データを階級ごとに分ける dplyr::mutate(class = cut(weight, breaks = pretty(weight, n = nclass.Sturges(weight)), include.lowest = FALSE, right = TRUE)) %&gt;% # 階級ごとの度数を求める dplyr::count(class) %&gt;% # 累積度数、相対度数、累積相対度数を求める dplyr::mutate(cumsum_n = cumsum(n), prop = prop.table(n), cumsum_prop = cumsum(prop)) %&gt;% # 階級値を求める dplyr::mutate(class_value = as.character(class)) %&gt;% tidyr::separate(class_value, into = c(&quot;l&quot;, &quot;h&quot;), sep = &quot;,&quot;) %&gt;% dplyr::mutate(l = as.integer(stringr::str_remove(l, &quot;[[:punct:]]&quot;)) + 1L, h = as.integer(stringr::str_remove(h, &quot;[[:punct:]]&quot;)), mids = (l + h) / 2L) %&gt;% # 変数名を日本語にする dplyr::select(`階級` = class, `階級値` = mids, `度数` = n, `累積度数` = cumsum_n, `相対度数` = prop, `累積相対度数` = cumsum_prop) ヒストグラムを描きます。 with(df, hist(weight)) Fig. 1.2: 解答例 以上 ヒストグラムを描くポイント ヒストグラムを描く（度数分布表を作成する）際のポイントは下記の点です。 階級の決め方 階級の境界の扱い 階級の決め方 階級を決める方法は特に定められていません。データが取る幅を見て切のよい値にすることが多いようです。ただし、階級のとり方によりヒストグラムの形状が変わる点には注意が必要です。例えば、身長データに対する階級をテキストと同様に\\(5cm\\)幅とした場合は下図のような形状になります。 with(x, hist(height, breaks = seq(from = 140, to = 170, by = 5))) Fig. 1.3: 階級幅5cmの場合 階級を倍の\\(10cm\\)幅とすると下図のようになります。 with(x, hist(height, breaks = seq(from = 140, to = 170, by = 10))) Fig. 1.4: 階級幅10cmの場合 逆に階級を半分の\\(2.5cm\\)幅とすると下図のようになります。 with(x, hist(height, breaks = seq(from = 140, to = 170, by = 2.5))) Fig. 1.5: 階級幅2.5cmの場合 更に細かくして\\(1cm\\)幅にすると下図のように歯抜けがある形状になります。 with(x, hist(height, breaks = seq(from = 140, to = 170, by = 1.0))) Fig. 1.6: 階級幅1cmの場合 このように階級の決め方次第でヒストグラムの形状が変わってくることが分かります。ヒストグラムはデータの分布をみるために使うグラフですので、過大な階級幅や過小な階級幅で描くことは好ましくありませんので、適切な値を選ぶようにしてください。 計算で階級を決める 適切な階級をどのように決めれば良いか迷う場合には、下表のような計算方法が提案されていますのでこれらを試してみてください。 階級の求め方 階級数（\\(k\\)）・階級幅（\\(h\\)） 備考 平方根選択（Square-root choice） \\(k = \\sqrt{n}\\) スタージェスの公式（Sturges’s formula） \\(k = \\lceil \\log_2n + 1 \\rceil\\) \\(n \\geq 30\\)が前提 スコットの選択（Scott’s choice） \\(h = \\frac{3.5\\sigma}{n^{1/3}}\\) フリードマン・ダイアコニスの選択（F-D’s choice） \\(h = 2\\frac{IQR(x)}{n^{1/3}}\\) 階級数（\\(k\\)）から階級幅（\\(h\\)）を求める場合は下式を使います。 \\[h = \\lceil \\frac{max(x) - min(x)}{k} \\rceil\\] \\(k\\) :階級の数 \\(h\\) :階級の幅 \\(n\\) :データの個数 \\(\\lceil x \\rceil\\) :天井関数（実数\\(x\\)に対して\\(x\\)以上の最小の整数を返す関数） \\(\\sigma\\) :標準偏差 \\(IQR\\) :四分位範囲 数式出典：Wikipedia スタージェスの公式 スタージェスの公式は、比較的、よく使われる計算方法です。ただし、データの数が\\(30\\)個未満の場合には適切ではありませんし、データの数が多くなるとヒストグラムを平滑化し過ぎる傾向があると言われています。そのような傾向が見られた場合には、他の計算方法や任意の階級も試してみてください。 with(x, hist(height, breaks = &quot;Sturges&quot;)) スコットの選択 スコットの選択は、データによってはスタージェスの公式と比べて階級数が少なくなる傾向があります。 with(x, hist(height, breaks = &quot;Scott&quot;)) フリードマン・ダイアコニスの選択 フリードマン・ダイアコニスの法則とも呼ばれます。 with(x, hist(height, breaks = &quot;FD&quot;)) Fig. 1.7: 階級をフリードマン・ダイアコニスの選択で求めた場合 階級の境界の扱い 階級は下表のように「下端値〜上端値」の形式で表示されることが多いですが、\\(140\\)は階級に含まれるのか？\\(145\\)はどちらの階級に含まれるのか？を決めておかないと意図しない度数になってしまう場合があります。 階級 度数 140〜145 1 145〜150 6 … … 160〜165 16 165〜170 6 例えば、階級を「\\(\\mbox{下端値} &lt; x \\leq \\mbox{上端値}\\)」と定義した場合は、下図のようになります。 with(x, hist(height, right = TRUE)) Fig. 1.8: 上端を含める場合 階級を「\\(\\mbox{下端値} \\leq x &lt;ｌ \\mbox{上端値}\\)」と定義した場合は、分布形状が異なることが分かります。 with(x, hist(height, right = FALSE)) Fig. 1.9: 下端を含める場合 このように階級によりヒストグラムの形状が変わってくる点には注意が必要です。なお、下端、上端の含め方を「左閉じ、右閉じ」と表現することもあります。 等間隔ではない階級 度数分布表の階級は必ずしも等間隔である必要はありません。例えば、下図の世帯貯蓄のように度数の小さい階級をまとめたヒストグラムをしばしば見かけます。等間隔でないは階級は（最小値と最大値で桁が数桁異なるなど）幅が広いデータにおいて、階級を細かくしたい場合や等幅の階級でグラフ化するとデータを読み取りにくい場合などに使われます。 knitr::include_graphics(&quot;https://www.stat.go.jp/naruhodo/img/picture/4_8_10.png&quot;) このように階級幅が等間隔でない場合には、柱（棒）の面積が度数に対応するように高さを調整する必要があります。 ヒストグラムは棒グラフとは異なり階級ごとの柱（棒）の面積が意味を持っています。高さは一般的に度数として表示されますが、密度として表示することもあります。高さ（密度）と幅（階級幅）を乗じたものが相対度数になります。相対度数は名前の通り度数に比例していますので、柱（棒）の面積が等しければ同じ度数ということを表します。 例えば、テキストにある身長のデータの\\(140cm\\)から\\(150cm\\)をひとつの階級にまとめた場合、度数分布表は下表のようになります。 x %&gt;% dplyr::mutate(class = cut(height, breaks = c(140, 150, 155, 160, 165, 170))) %&gt;% dplyr::count(class) %&gt;% dplyr::mutate(prop = prop.table(n)) %&gt;% dplyr::rename(`階級` = class, `度数` = n, `相対度数` = prop) これをヒストグラムとして描いた場合は、下図のようにならなければなりません。この図では縦軸は度数でなく密度になっています。 with(x, hist(height, breaks = c(140, 150, 155, 160, 165, 170))) Fig. 1.10: 正しいヒストグラム 密度（高さ）は左から 0.00875, 0.0475, 0.075, 0.045, 0.015 となっていますので、これに個々の階級幅（幅） 10, 5, 5, 5, 5 を乗じると個々の柱（棒）の面積は 0.0875, 0.2375, 0.375, 0.225, 0.075 となり、相対度数と等しいことがわかります。 度数を表示させるために下図のようなヒストグラムを描くことは好ましくありません。階級幅が等幅でない場合は度数分布表と共に密度のヒストグラムを示した方がよいでしょう。 with(x, hist(height, breaks = c(140, 150, 155, 160, 165, 170), freq = TRUE)) Fig. 1.11: 好ましくないヒストグラム（単なる棒グラフ） "],["平均値とはやじろべえの視点である.html", "第2講 平均値とはやじろべえの視点である 2.1 統計量は、データを要約する数値 2.2 平均値とは 2.3 度数分布表での平均値 {#2-3＃} 2.4 平均値のヒストグラムの中での役割 2.5 平均値をどう捉えるべきか 2.6 練習問題 【コラム】平均値のとり方は、１つではない 階級幅が変わると平均値はどうなるか？", " 第2講 平均値とはやじろべえの視点である 本講では以下のデータフレームを利用しています。 身長データ x 度数分布表 df 2.1 統計量は、データを要約する数値 本稿で扱っている統計量（要約統計量）は平均のみです。 2.2 平均値とは 本稿の平均値とは算術平均を意味しています。身長データ（\\(x\\)）の平均値は157.575です。 2.3 度数分布表での平均値 {#2-3＃} df %&gt;% dplyr::select(`階級` = class, `度数` = n, `階級値` = mids, `階級幅` = range, `累積度数` = cumsum_n, `相対度数` = prop, `累積相対度数` = cumsum_prop) （算術）平均は全ての観測値の総和を総データ数で除したものですので、観測値を各階級の代表値である階級値で近似すると下式が成り立つことが分かります。 \\[\\mbox{平均} = \\frac{\\sum{\\mbox{観測値}_i}}{総データ数} = \\frac{\\sum{\\mbox{観測値}_i}}{\\sum{度数}_i} \\fallingdotseq \\frac{\\sum{(\\mbox{階級値}_i \\times \\mbox{度数}_i)}}{\\sum{度数}_i} = \\sum{(\\mbox{階級値}_i \\times \\mbox{相対度数}_i)}\\] なぜなら \\[\\frac{\\mbox{度数}_i}{\\sum{\\mbox{度数}_i}} = \\mbox{相対度数}_i\\] \\[i = 1, 2, ... , n\\] df %&gt;% dplyr::select(A = mids, B = prop) %&gt;% dplyr::mutate(`A x B` = A * B) %&gt;% dplyr::rename(`A 階級値` = A, `B 相対度数` = B, `A x B` = `A x B`) df %&gt;% dplyr::select(A = mids, B = prop) %&gt;% dplyr::mutate(`A x B` = A * B) %&gt;% dplyr::summarise(`平均値` = sum(`A x B`)) 実データで求めた平均値は157.575ですので、階級値から求めた平均値との差は-0.175となり、度数分布表を作ることは平均値に大きな影響を与えないことが分かります。 2.4 平均値のヒストグラムの中での役割 階級値から求めた平均値をヒストグラム上にプロットすると下図のようになります。 with(x, hist(height)) abline(v = 157.75, lty = 2) 2.5 平均値をどう捉えるべきか 平均値の捉え方は様々考えられますが、テキストでは下記のようにまとめています。 全データ（値）を代表する値（点） データは平均値の周辺に分布する 数多く現れるデータは平均値への影響が大きい データの分布が対象の場合、平均値は対象軸 2.6 練習問題 2.6.1 解答例 data.frame(mids = c(30, 50, 70, 90, 110, 130), n = c(5, 10, 15, 40, 20, 10)) %&gt;% dplyr::mutate(prop = prop.table(n), cm = mids * prop) %&gt;% dplyr::rename(`階級値` = mids, `度数` = n, `相対度数` = prop, `階級値×相対度数` = cm) data.frame(mids = c(30, 50, 70, 90, 110, 130), n = c(5, 10, 15, 40, 20, 10)) %&gt;% dplyr::mutate(prop = prop.table(n), cm = mids * prop) %&gt;% dplyr::summarise(`平均値` = sum(cm)) 【コラム】平均値のとり方は、１つではない 算術平均（Arithmetic Mean） \\[\\frac{\\sum_{i=1}^n{x_i}}{n}\\] sum(c(10, 90)) / length(c(10, 90)) ## [1] 50 mean(c(10, 90)) ## [1] 50 幾何平均（Geometric Mean）または相乗平均 \\[\\sqrt{\\prod_{i=1}^n{x_i}}\\] psych::geometric.mean(c(10, 90)) ## [1] 30 二乗平均（Root Mean Square） \\[\\sqrt{\\frac{\\sum_{i=1}^n{x_i^2}}{n}}\\] sqrt(mean(c(10, 90) ^ 2)) ## [1] 64.03124 調和平均（Harmonic Mean） \\[\\frac{n}{\\sum_{i=1}^n{\\frac{1}{x_i}}}\\] psych::harmonic.mean(c(10, 90)) ## [1] 18 トリム平均 トリム平均は体操競技の評点などで使われる平均値の計算方法で、値を小さい方から順に並べ、上位側と下位側から一定の割合で値を除き算術平均を求めます。外れ値や異常値などを影響を排除するために使われることが多いです。 mean(c(0, 1:8, 30)) ## [1] 6.6 mean(c(0, 1:8, 30), trim = 0.25) # データの両側2.5%を対象外とする ## [1] 4.5 階級幅が変わると平均値はどうなるか？ では、階級幅が変わると度数分布表から求める平均値はどのようになるか確認してみましょう。 階級幅が倍になった場合 x %&gt;% dplyr::mutate(class = cut(height, breaks = c(140, 150, 160, 170), include.lowest = FALSE, right = TRUE)) %&gt;% dplyr::count(class) %&gt;% dplyr::mutate(class_value = as.character(class)) %&gt;% tidyr::separate(class_value, into = c(&quot;l&quot;, &quot;h&quot;), sep = &quot;,&quot;) %&gt;% dplyr::mutate(l = as.numeric(stringr::str_remove(l, &quot;[[:punct:]]&quot;)), h = as.numeric(stringr::str_remove(h, &quot;[[:punct:]]&quot;))) %&gt;% dplyr::mutate(mids = ((l + 1) + h) / 2) %&gt;% dplyr::mutate(range = h - l, cumsum_n = cumsum(n), prop = prop.table(n), cumsum_prop = cumsum(prop)) %&gt;% dplyr::select(A = mids, B = prop) %&gt;% dplyr::mutate(`A x B` = A * B) %&gt;% dplyr::summarise(`階級値による平均値` = sum(`A x B`)) %&gt;% dplyr::mutate(`算術平均` = mean(x$height), `差` = `算術平均` - `階級値による平均値`) 階級幅が半分になった場合 x %&gt;% dplyr::mutate(class = cut(height, breaks = seq(from = 140, to = 170, by = 2.5), include.lowest = FALSE, right = TRUE)) %&gt;% dplyr::count(class) %&gt;% dplyr::mutate(class_value = as.character(class)) %&gt;% tidyr::separate(class_value, into = c(&quot;l&quot;, &quot;h&quot;), sep = &quot;,&quot;) %&gt;% dplyr::mutate(l = as.numeric(stringr::str_remove(l, &quot;[[:punct:]]&quot;)), h = as.numeric(stringr::str_remove(h, &quot;[[:punct:]]&quot;))) %&gt;% dplyr::mutate(mids = ((l + 1) + h) / 2) %&gt;% dplyr::mutate(range = h - l, cumsum_n = cumsum(n), prop = prop.table(n), cumsum_prop = cumsum(prop)) %&gt;% dplyr::select(A = mids, B = prop) %&gt;% dplyr::mutate(`A x B` = A * B) %&gt;% dplyr::summarise(`階級値による平均値` = sum(`A x B`)) %&gt;% dplyr::mutate(`算術平均` = mean(x$height), `差` = `算術平均` - `階級値による平均値`) "],["データの散らばり具合を見積もる統計量.html", "第3講 データの散らばり具合を見積もる統計量 3.1 データの散らばりやバラツキを知りたい 3.2 バスの到着時刻の例で分散を理解する 3.3 標準偏差の意味 3.4 度数分布表から標準偏差を求める 練習問題 身長データの度数分布表から分散と標準偏差を求める", " 第3講 データの散らばり具合を見積もる統計量 3.1 データの散らばりやバラツキを知りたい 第2講で学んだ平均値（算術平均）は、データを代表する統計量で、ある一点（支点・重心）を示しているに過ぎません。データが平均値の周辺にどのように分布しているかはヒストグラムを使うことで視覚的には確認できますが、統計量として数値的に扱えた方がなにかと便利なはずです。 3.2 バスの到着時刻の例で分散を理解する 蛇足ですが実際の路線バスでは予定時刻より早く到着しないように調整運転がなされていますので、時刻より大幅に早着することは稀です。 x &lt;- scan(file = &quot;../data/P36_図表3-1.csv&quot;, sep = &quot;,&quot;) x ## [1] 32 27 29 34 33 平均値を求めるmean()関数がありますが、ここでは平均値の計算式通りの計算を行っています。 `平均値` &lt;- sum(x) / length(x) `平均値` ## [1] 31 `偏差` = x - `平均値` `偏差` ## [1] 1 -4 -2 3 2 偏差の総和は必ずゼロ（\\(0\\)）になります。 sum(`偏差`) ## [1] 0 偏差の二乗和をデータの個数で割ったものは、（標本）分散と呼ばれます。不偏分散と呼ばれる分散は計算式が異なります。Rで分散を計算するvar()関数は不偏分散を求める関数です。 sum(`偏差` ^ 2) / length(x) ## [1] 6.8 偏差の二乗平均値（\\(= \\sqrt{\\mbox{分散}}\\)）は標準偏差と呼ばれます。Rで標準偏差を計算するsd()関数は不偏分散のルートを取ったものです。 sqrt(sum(`偏差` ^ 2) / length(x)) ## [1] 2.607681 3.3 標準偏差の意味 x &lt;- read.csv(file = &quot;../data/P39_図表3-4.csv&quot;) x ｘ mean &lt;- x %&gt;% dplyr::summarise(`X平均値` = mean(X), `Y平均値` = mean(Y)) mean x %&gt;% dplyr::mutate(`X偏差` = X - mean$`X平均値`, `Y偏差` = Y - mean$`Y平均値`) x %&gt;% dplyr::mutate(`X偏差` = X - mean$`X平均値`, `Y偏差` = Y - mean$`Y平均値`) %&gt;% dplyr::summarise(`X標準偏差` = sqrt(sum(`X偏差` ^ 2) / length(X)), `Y標準偏差` = sqrt(sum(`Y偏差` ^ 2) / length(Y))) 偏差と標準偏差を可視化すると下図のようになり、XよりYの方が広範囲に分布していることが分かります。 x %&gt;% dplyr::mutate(`X偏差` = X - mean$`X平均値`, `Y偏差` = Y - mean$`Y平均値`) %&gt;% dplyr::select(-X, -Y) %&gt;% stripchart(xlim = c(-5, 5)) abline(v = c(-0.89, 0.89), lty = 2) abline(v = c(-3.03, 3.03), lty = 3, col = 2) 3.4 度数分布表から標準偏差を求める x &lt;- read.csv(file = &quot;../data/P40_図表3-6.csv&quot;) x 第2講の「2−3 度数分布表での平均値」で学んだように度数分布表から平均値（の近似値）は \\[\\mbox{平均値} \\fallingdotseq \\sum{(\\mbox{階級値} \\times \\mbox{相対度数})}\\] で求めることができます。 x %&gt;% dplyr::mutate(`AxB` = `A階級値` * `B相対度数`) `平均値` &lt;- x %&gt;% dplyr::mutate(`AxB` = `A階級値` * `B相対度数`) %&gt;% dplyr::summarize(`平均値` = sum(`AxB`)) %&gt;% dplyr::pull(`平均値`) `平均値` ## [1] 2 平均値を求められたので \\[\\mbox{階級の偏差（C階級値-平均値）} = \\mbox{階級値} - \\mbox{平均値}\\] とすると度数分布表の計算値と同じ考え方を適用し \\[\\mbox{階級の偏差の二乗平均} = \\sum{(\\mbox{階級の偏差}^2 \\times \\mbox{相対度数})} = \\mbox{分散}\\] となります。 x %&gt;% dplyr::mutate(`C` = `A階級値` - `平均値`) %&gt;% dplyr::mutate(`C^2` = `C` ^ 2) %&gt;% dplyr::mutate(`C^2xB` = `C^2` * `B相対度数`) %&gt;% dplyr::select(`A階級値`, `C階級値-平均値` = `C`, `C^2`, `B相対度数`, `C^2xB`) x %&gt;% dplyr::mutate(`C` = `A階級値` - `平均値`) %&gt;% dplyr::mutate(`C^2` = `C` ^ 2) %&gt;% dplyr::mutate(`C^2xB` = `C^2` * `B相対度数`) %&gt;% dplyr::select(`A階級値`, `C階級値-平均値` = `C`, `C^2`, `B相対度数`, `C^2xB`) %&gt;% dplyr::summarise(`分散` = sum(`C^2xB`)) %&gt;% dplyr::mutate(`標準偏差` = sqrt(`分散`)) 練習問題 次の架空のデータの標準偏差を次のステップで計算してみよ。 `データ` &lt;- scan(file = &quot;../data/P42_練習問題_v.csv&quot;, sep = &quot;,&quot;) `データ` ## [1] 6 4 6 6 6 3 7 2 2 8 解答例 `平均値` &lt;- sum(`データ`) / length(`データ`) `平均値` ## [1] 5 `偏差` &lt;- `データ` - `平均値` `偏差` ## [1] 1 -1 1 1 1 -2 2 -3 -3 3 `二乗偏差` &lt;- `偏差` ^ 2 `二乗偏差` ## [1] 1 1 1 1 1 4 4 9 9 9 `分散` &lt;- sum(`二乗偏差`) / length(`二乗偏差`) `分散` ## [1] 4 `標準偏差` &lt;- sqrt(`分散`) `標準偏差` ## [1] 2 身長データの度数分布表から分散と標準偏差を求める 解答例 x %&gt;% dplyr::mutate(`AxB` = `A階級値` * `B相対度数`) `平均値` &lt;- x %&gt;% dplyr::mutate(`AxB` = `A階級値` * `B相対度数`) %&gt;% dplyr::summarise(`平均値` = sum(`AxB`)) %&gt;% dplyr::pull(`平均値`) `平均値` ## [1] 157.7625 x %&gt;% dplyr::mutate(`C` = `A階級値` - `平均値`) %&gt;% dplyr::mutate(`C^2` = `C` ^ 2) %&gt;% dplyr::mutate(`C^2xB` = `C^2` * `B相対度数`) freq_summary &lt;- x %&gt;% dplyr::mutate(`C` = `A階級値` - `平均値`) %&gt;% dplyr::mutate(`C^2` = `C` ^ 2) %&gt;% dplyr::mutate(`C^2xB` = `C^2` * `B相対度数`) %&gt;% dplyr::summarise(`平均` = sum(`A階級値` * `B相対度数`), `分散` = sum(`C^2xB`)) %&gt;% dplyr::mutate(`標準偏差` = sqrt(`分散`)) freq_summary 生データで計算した場合 &quot;../data/P16_図表1-1 .csv&quot; %&gt;% readr::read_csv(col_names = FALSE, show_col_types = FALSE) %&gt;% tidyr::pivot_longer(cols = dplyr::starts_with(&quot;X&quot;), names_to = &quot;name&quot;, values_to = &quot;value&quot;) %&gt;% dplyr::arrange(name) %&gt;% dplyr::select(height = value) %&gt;% dplyr::mutate(`偏差` = height - mean(height)) %&gt;% dplyr::mutate(`偏差^2` = `偏差` ^ 2) raw_summary &lt;- &quot;../data/P16_図表1-1 .csv&quot; %&gt;% readr::read_csv(col_names = FALSE, show_col_types = FALSE) %&gt;% tidyr::pivot_longer(cols = dplyr::starts_with(&quot;X&quot;), names_to = &quot;name&quot;, values_to = &quot;value&quot;) %&gt;% dplyr::arrange(name) %&gt;% dplyr::select(height = value) %&gt;% dplyr::mutate(`偏差` = height - mean(height)) %&gt;% dplyr::mutate(`偏差^2` = `偏差` ^ 2) %&gt;% dplyr::summarise(`平均` = sum(height) / length(height), `分散` = sum(`偏差^2`) / length(height), `標準偏差` = sqrt(`分散`)) raw_summary 要約統計量を比べてみると以下のようになります。 freq_summary # 度数分布表からの要約統計量 raw_summary # 生データからの要約統計量 freq_summary - raw_summary # 両者の差 "],["そのデータは月並みか特殊か-標準偏差で評価する.html", "第4講 そのデータは「月並み」か「特殊」か？ 標準偏差で評価する 4.1 標準偏差は波の「激しさ」 4.2 S.D.がわかるとデータの特殊性を評価できる 4.3 複数のデータセットの比較 4.4 加工されたデータの平均値と標準偏差 練習問題 【コラム】偏差値で嫌な思いをしたことのあるあなたに", " 第4講 そのデータは「月並み」か「特殊」か？ 標準偏差で評価する 4.1 標準偏差は波の「激しさ」 4.2 S.D.がわかるとデータの特殊性を評価できる 4.3 複数のデータセットの比較 4.4 加工されたデータの平均値と標準偏差 練習問題 解答例 【コラム】偏差値で嫌な思いをしたことのあるあなたに "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
