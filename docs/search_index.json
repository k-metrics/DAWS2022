[["index.html", "Rで学ぶ『完全独習 統計学入門』 はじめに 想定読者", " Rで学ぶ『完全独習 統計学入門』 Sampo Suzuki, CC 4.0 BY-NC-SA 2022-04-17 はじめに 本資料は『完全独習 統計学入門』小島寛之著（以降、テキスト）の内容をRで計算する方法を紹介しています。基本的な統計量を求める際に必要となる関数などの解説が中心です。 テキストに記載されているデータの一部をCSVファイルにして利用していますが、データ自体の著作権は原著作者にあります。また、CSVファイルは著作権を侵害する意図で作成したものではありません。 想定読者 本書の想定読者は以下に該当する方です。 Rに関する基本的な知識を有している方 データフレーム型や因子型などの変数型の知識 変数の代入・参照方法 tidyverseの基本的な知識 Rで統計量を求めてみたい方 本書ではRのインストール方法や基本文法には触れません。 "],["度数分布表とヒストグラムでデータの特徴を浮き彫りにする.html", "第1講 度数分布表とヒストグラムでデータの特徴を浮き彫りにする 1.1 生データでは何もわからないから統計を使う 1.2 ヒストグラムを作る 1.3 練習問題", " 第1講 度数分布表とヒストグラムでデータの特徴を浮き彫りにする 1.1 生データでは何もわからないから統計を使う テキストの図表1-1のデータは4列20行からなるデータです。 Rでは、このような形式のデータ（雑然データ）をそのまま使わずに整然データ（Tidy Data）と呼ばれる形式に変換した方が効率的に処理できます。変換にはtidyverseファミリーを利用するのが効率的です。 library(tidyverse) # ローカルにあるデータファイルを読み込む x &lt;- &quot;../data/P16_図表1-1 .csv&quot; %&gt;% readr::read_csv(col_names = FALSE, show_col_types = FALSE) %&gt;% # 読み込んだデータを縦長形式（Tidy Data）に変換する tidyr::pivot_longer(cols = dplyr::starts_with(&quot;X&quot;), names_to = &quot;name&quot;, values_to = &quot;value&quot;) %&gt;% # X1, X2, ... , X4, X1 の順で行方向に読み込まれるので列方向で整列する dplyr::arrange(name) %&gt;% # 必要なデータ列（value）の列名をheightに変更して取り出す dplyr::select(height = value) x このような形式に変換することで、様々な統計量を効率的に求めることができるようになります。 1.2 ヒストグラムを作る テキストでは度数分布表を作成してからヒストグラムを描いています。その手順は 最大・最小値を求める 階級を決める 度数をカウントする 相対度数を求める 累積度数を求める ここまでで度数分布表ができる 度数分布表をもとにヒストグラムを描く となっていますが、Rではhist()関数だけでヒストグラムを描くことができます。hist()関数の引数はベクトル型に限定されますので、データフレーム型の場合は参照演算子（$）などでベクトル型データを取り出す必要があります。 hist(x = x$height) hist()関数はヒストグラムを描くために必要となる階級や度数、階級値などの情報を出力することも可能です。 hist(x = x$height, plot = FALSE) ## $breaks ## [1] 140 145 150 155 160 165 170 ## ## $counts ## [1] 1 6 19 30 18 6 ## ## $density ## [1] 0.0025 0.0150 0.0475 0.0750 0.0450 0.0150 ## ## $mids ## [1] 142.5 147.5 152.5 157.5 162.5 167.5 ## ## $xname ## [1] &quot;x$height&quot; ## ## $equidist ## [1] TRUE ## ## attr(,&quot;class&quot;) ## [1] &quot;histogram&quot; 主な出力の意味 出力名 意味 備考 $breaks 階級 デフォルトはスタージェスの公式*にもとづく区切り（幅） $counts 度数 各階級に入るデータの個数 $density 密度 密度推定値 $mids 階級値 階級の中央値（階級の単純平均） * 後述 表形式の度数分布表を作成する場合は以下のようにコード処理します。 x %&gt;% # 階級を求めて、データを階級ごとに分ける dplyr::mutate(class = cut(height, breaks = pretty(height, n = nclass.Sturges(height)), include.lowest = FALSE, right = TRUE)) %&gt;% # 階級ごとの度数を求める dplyr::count(class) %&gt;% # 累積度数、相対度数、累積相対度数を求める dplyr::mutate(cumsum_n = cumsum(n), prop = prop.table(n), cumsum_prop = cumsum(prop)) %&gt;% # 階級値を求める dplyr::mutate(class_value = as.character(class)) %&gt;% tidyr::separate(class_value, into = c(&quot;l&quot;, &quot;h&quot;), sep = &quot;,&quot;) %&gt;% dplyr::mutate(l = as.integer(stringr::str_remove(l, &quot;[[:punct:]]&quot;)) + 1L, h = as.integer(stringr::str_remove(h, &quot;[[:punct:]]&quot;)), mids = (l + h) / 2L) %&gt;% # 変数名を日本語にする dplyr::select(`階級` = class, `階級値` = mids, `度数` = n, `累積度数` = cumsum_n, `相対度数` = prop, `累積相対度数` = cumsum_prop) 以降の項は度数分布表の作成に必要な関数の使い方を紹介していますので、不要な方は演習問題まで読み飛ばしてください。 1.2.1 階級を求める 以降に出てくるwith()関数は、第一引数で指定するデータフレーム型変数内の変数名を第二引数内で参照演算子（$）を用いることなく参照できるようにする関数です。 階級を求めるにはpretty()関数を使います。 with(x, pretty(x = height, n = nclass.Sturges(height))) ## [1] 140 145 150 155 160 165 170 第一引数xには階級を求めたいベクトル型データを第二引数nには階級を区切りたい数（階級数）を指定します。ここでは、階級数nにはスタージェスの公式から求めた階級数を指定しています。 ただし、必ずしも指定した階級数に分割される訳ではない点に注意してください。xで指定したデータが階級に収まるように適切な丸め処理を行いますので、指定した階級数とは異なる階級が求められることもあります。 スタージェスの公式は、階級数を\\(k\\)、データのサイズ（数）を\\(n\\)とした場合、下式で定義されます。 \\[k = \\log_2(n) + 1\\] スタージェスの公式はnclass.Sturgess()関数として実装されています。 with(x, nclass.Sturges(height)) ## [1] 8 スタージェスの公式はヒストグラムを平滑化し過ぎる傾向があると言われています。気になる場合はスコットの選択（nclass.scott()）やフリードマン=ダイアコニスの選択（nclass.FD()）を試して見てください。 1.2.2 データを各階級に分類する データを階級分けするにはcut()関数を使います。 with(x, cut(x = height, breaks = pretty(height, n = nclass.Sturges(height)))) ## [1] (150,155] (150,155] (155,160] (155,160] (160,165] (155,160] (155,160] ## [8] (155,160] (150,155] (155,160] (150,155] (160,165] (155,160] (160,165] ## [15] (155,160] (160,165] (160,165] (165,170] (145,150] (160,165] (150,155] ## [22] (160,165] (155,160] (160,165] (165,170] (150,155] (155,160] (150,155] ## [29] (155,160] (155,160] (155,160] (145,150] (160,165] (150,155] (155,160] ## [36] (160,165] (150,155] (160,165] (150,155] (150,155] (150,155] (150,155] ## [43] (155,160] (145,150] (145,150] (160,165] (165,170] (150,155] (150,155] ## [50] (165,170] (160,165] (160,165] (145,150] (140,145] (155,160] (160,165] ## [57] (155,160] (155,160] (155,160] (160,165] (165,170] (155,160] (155,160] ## [64] (150,155] (155,160] (155,160] (150,155] (155,160] (150,155] (155,160] ## [71] (145,150] (165,170] (150,155] (155,160] (155,160] (155,160] (160,165] ## [78] (155,160] (155,160] (160,165] ## Levels: (140,145] (145,150] (150,155] (155,160] (160,165] (165,170] 第一引数xには階級分けの対象となるベクトル型変数を第二引数breaksには前項で求めた階級を指定します。breaks引数には任意の階級、例えばbreaks = c(140, 155, 170)のように指定することも可能です。 階級の境界値はどちらに含まれるのか？ cut()関数の出力は、(140,145] (145,150]のように階級間で同じ数値、この場合は145が含まれます。では、145はどちらの階級に含まれるのでしょうか？答えは、添えられている括弧にあります。 (140,145] は「140を超えて145以下」となりますので、次の (145,150] は同様に「145を超えて150以下」となります。階級間の境界値である145は(140, 145]側に入ります。 (は「超えて」（境界値を含まない）、]は「以下」（境界値を含む） で、逆向きの場合は )は「未満」（境界値を含まない）、[は「以上」（境界値を含む） となります。hist()関数の階級も同様です。 境界値をどちらに含めるかはinclude.lowest引数とright引数で指定できます。 option right = TRUE right = FALSE include.lowest = TRUE [l,u] ... (l,u] [l,u) ... [l,u] include.lowest = FALSE (l,u] ... (l,u]* [l,u) ... [l,u) *デフォルト 例えばデータの最大値と最小値を境界値として含む階級を指定した場合、include.lowest = FALSE, right = FALSEと指定すると最大値が階級に含まれなくなります。 with(x, cut(height, breaks = c(143, 155, 169), include.lowest = FALSE, right = FALSE)) ## [1] [143,155) [143,155) [155,169) [155,169) [155,169) [155,169) [155,169) ## [8] [155,169) [143,155) [155,169) [143,155) [155,169) [155,169) [155,169) ## [15] [155,169) [155,169) [155,169) &lt;NA&gt; [143,155) [155,169) [143,155) ## [22] [155,169) [155,169) [155,169) [155,169) [143,155) [155,169) [155,169) ## [29] [155,169) [155,169) [155,169) [143,155) [155,169) [155,169) [155,169) ## [36] [155,169) [143,155) [155,169) [143,155) [143,155) [143,155) [155,169) ## [43] [155,169) [143,155) [143,155) [155,169) &lt;NA&gt; [143,155) [155,169) ## [50] [155,169) [155,169) [155,169) [143,155) [143,155) [155,169) [155,169) ## [57] [155,169) [155,169) [155,169) [155,169) [155,169) [155,169) [155,169) ## [64] [143,155) [155,169) [155,169) [143,155) [155,169) [143,155) [155,169) ## [71] [143,155) [155,169) [143,155) [155,169) [155,169) [155,169) [155,169) ## [78] [155,169) [155,169) [155,169) ## Levels: [143,155) [155,169) 逆にinclude.lowest = FALSE, right = TRUEと指定すると最小値が階級に含まれなくなります。 with(x, cut(height, breaks = c(143, 155, 169), include.lowest = FALSE, right = TRUE)) ## [1] (143,155] (143,155] (155,169] (155,169] (155,169] (155,169] (155,169] ## [8] (155,169] (143,155] (155,169] (143,155] (155,169] (155,169] (155,169] ## [15] (155,169] (155,169] (155,169] (155,169] (143,155] (155,169] (143,155] ## [22] (155,169] (155,169] (155,169] (155,169] (143,155] (155,169] (143,155] ## [29] (155,169] (155,169] (155,169] (143,155] (155,169] (143,155] (155,169] ## [36] (155,169] (143,155] (155,169] (143,155] (143,155] (143,155] (143,155] ## [43] (155,169] (143,155] (143,155] (155,169] (155,169] (143,155] (143,155] ## [50] (155,169] (155,169] (155,169] (143,155] &lt;NA&gt; (155,169] (155,169] ## [57] (155,169] (155,169] (155,169] (155,169] (155,169] (155,169] (155,169] ## [64] (143,155] (155,169] (155,169] (143,155] (155,169] (143,155] (155,169] ## [71] (143,155] (155,169] (143,155] (155,169] (155,169] (155,169] (155,169] ## [78] (155,169] (155,169] (155,169] ## Levels: (143,155] (155,169] 1.2.3 度数を求める 度数を求めるには各階級の数を数えます。数を数えるにはtable()関数やdplyr::count()関数を使います。table()関数はベクトル型を対象に、dplyr::count()関数はデータフレーム型を対象として個数をカウントします。用途によって使い分けてください。 with(x, table(cut(height, breaks = pretty(height, n = nclass.Sturges(height))))) ## ## (140,145] (145,150] (150,155] (155,160] (160,165] (165,170] ## 1 6 19 30 18 6 x %&gt;% # 階級を求めて、データを階級ごとに分ける dplyr::mutate(class = cut(height, breaks = pretty(height, n = nclass.Sturges(height)))) %&gt;% # 階級ごとの度数を求める dplyr::count(class) 1.2.4 累積度数、相対度数、累積相対度数を求める 累積度数（度数の累積和）を求めるにはcumsum()関数を使います。 with(x, cumsum(table(cut(height, breaks = pretty(height, n = nclass.Sturges(height)))))) ## (140,145] (145,150] (150,155] (155,160] (160,165] (165,170] ## 1 7 26 56 74 80 相対度数を求めるにはprop.table()関数を使います。 with(x, prop.table(table(cut(height, breaks = pretty(height, n = nclass.Sturges(height)))))) ## ## (140,145] (145,150] (150,155] (155,160] (160,165] (165,170] ## 0.0125 0.0750 0.2375 0.3750 0.2250 0.0750 累積相対度数は相対度数の累積和ですので、prop.table()関数の結果をcumsum()関数に渡すことで求めることができます。 with(x, cumsum(prop.table(table(cut(height, breaks = pretty(height, n = nclass.Sturges(height))))))) ## (140,145] (145,150] (150,155] (155,160] (160,165] (165,170] ## 0.0125 0.0875 0.3250 0.7000 0.9250 1.0000 1.2.5 階級値を求める 階級値は階級の文字列から下限と上限の境界値を抜き出し、下式で単純平均として求めています。 \\[\\frac{(\\mbox{下限} + 1) + \\mbox{上限}}{2}\\] 手順としては以下のようにしています。 as.character()関数で 階級（class）を文字型に変換し、新しい変数（class_value）を作成する tidyr::separate()関数で文字型の変数（class_value）を,の前後で二つの変数（l, h）に分割する stringr::str_remove関数で二つの変数（l, h）から(や]を取り除きas.numeric()関数で文字列から数値に変換する 数値に変換された二つの変数から（l, h）平均値を求める x %&gt;% # 階級を求めて、データを階級ごとに分ける dplyr::mutate(class = cut(height, breaks = pretty(height, n = nclass.Sturges(height)), include.lowest = FALSE, right = TRUE)) %&gt;% # 階級ごとの度数を求める dplyr::count(class) %&gt;% # 階級値を求める dplyr::mutate(class_value = as.character(class)) %&gt;% tidyr::separate(class_value, into = c(&quot;l&quot;, &quot;h&quot;), sep = &quot;,&quot;) %&gt;% dplyr::mutate(l = as.numeric(stringr::str_remove(l, &quot;[[:punct:]]&quot;)), h = as.numeric(stringr::str_remove(h, &quot;[[:punct:]]&quot;))) %&gt;% dplyr::mutate(mids = ((l + 1) + h) / 2) 1.3 練習問題 テキストP23にあるデータで度数分布表とヒストグラムを作成する。 解答例 まず、処理しやすいように下記のように対象データを変形しdfというデータフレーム型の変数に格納しておきます。 df 度数分布表を身長の場合と同じ要領で作成します。 df %&gt;% # 階級を求めて、データを階級ごとに分ける dplyr::mutate(class = cut(weight, breaks = pretty(weight, n = nclass.Sturges(weight)), include.lowest = FALSE, right = TRUE)) %&gt;% # 階級ごとの度数を求める dplyr::count(class) %&gt;% # 累積度数、相対度数、累積相対度数を求める dplyr::mutate(cumsum_n = cumsum(n), prop = prop.table(n), cumsum_prop = cumsum(prop)) %&gt;% # 階級値を求める dplyr::mutate(class_value = as.character(class)) %&gt;% tidyr::separate(class_value, into = c(&quot;l&quot;, &quot;h&quot;), sep = &quot;,&quot;) %&gt;% dplyr::mutate(l = as.integer(stringr::str_remove(l, &quot;[[:punct:]]&quot;)) + 1L, h = as.integer(stringr::str_remove(h, &quot;[[:punct:]]&quot;)), mids = (l + h) / 2L) %&gt;% # 変数名を日本語にする dplyr::select(`階級` = class, `階級値` = mids, `度数` = n, `累積度数` = cumsum_n, `相対度数` = prop, `累積相対度数` = cumsum_prop) ヒストグラムを描きます。 with(df, hist(weight)) 以上 "],["平均値とはやじろべえの視点である.html", "第2講 平均値とはやじろべえの視点である 2.1 統計量は、データを要約する数値 2.2 平均値とは 2.3 度数分布表での平均値 2.4 平均値のヒストグラムの中での役割 2.5 平均値をどう捉えるべきか 2.6 練習問題 2.7 【コラム】平均値のとり方は、１つではない", " 第2講 平均値とはやじろべえの視点である 2.1 統計量は、データを要約する数値 2.2 平均値とは 2.3 度数分布表での平均値 2.4 平均値のヒストグラムの中での役割 2.5 平均値をどう捉えるべきか 2.6 練習問題 2.7 【コラム】平均値のとり方は、１つではない 算術平均（Arithmetic Mean） 幾何平均（Geometric Mean）または相乗平均 psych::geometric.mean(x) 二乗平均（Mean Square） mean(x ^ 2) 二乗平均平方根（Root Mean Square） sqrt(mean(x ^ 2)) Metrics::rmse() # Root Mean Squared Error 調和平均（Harmonic Mean） psych::harmonic.mean(x) トリム平均 mean(x, trim = 0.05) # データの5%を外側から対象外とする "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
