[["index.html", "Rで学ぶ『完全独習 統計学入門』 はじめに", " Rで学ぶ『完全独習 統計学入門』 Sampo Suzuki, CC 4.0 BY-NC-SA 2022-04-16 はじめに 本資料は『完全独習 統計学入門』小島寛之著（以降、テキスト）を用いてRを学ぶために作成しています。 テキストに記載されているデータの一部をCSVファイルにして利用していますが、データ自体の著作権は原著作者にあります。また、CSVファイルは著作権を侵害する意図で作成したものではありません。 "],["度数分布表とヒストグラムでデータの特徴を浮き彫りにする.html", "第1講 度数分布表とヒストグラムでデータの特徴を浮き彫りにする 1.1 統計を使う 1.2 ヒストグラムを作る 1.3 練習問題", " 第1講 度数分布表とヒストグラムでデータの特徴を浮き彫りにする 本講で扱うデータはテキストのP16 図表1-1で示されているデータですが、Rで処理しやすいように以下のように一列にまとめてxというデータフレーム型変数に格納しておきます。 x 1.1 統計を使う 1.2 ヒストグラムを作る Rでヒストグラムを描くにはhist()関数を使います。ヒストグラムを描くために計算した階級や度数、階級値などの情報を出力することも可能です。 hist &lt;- hist(x$height) hist ## $breaks ## [1] 140 145 150 155 160 165 170 ## ## $counts ## [1] 1 6 19 30 18 6 ## ## $density ## [1] 0.0025 0.0150 0.0475 0.0750 0.0450 0.0150 ## ## $mids ## [1] 142.5 147.5 152.5 157.5 162.5 167.5 ## ## $xname ## [1] &quot;x$height&quot; ## ## $equidist ## [1] TRUE ## ## attr(,&quot;class&quot;) ## [1] &quot;histogram&quot; 度数分布表を作成する場合は以下のようにします。 x %&gt;% # 階級を求めて、データを階級ごとに分ける dplyr::mutate(class = cut(height, breaks = pretty(height, n = nclass.Sturges(height)), include.lowest = FALSE, right = TRUE)) %&gt;% # 階級ごとの度数を求める dplyr::count(class) %&gt;% # 累積度数、相対度数、累積相対度数を求める dplyr::mutate(cumsum_n = cumsum(n), prop = prop.table(n), cumsum_prop = cumsum(prop)) %&gt;% # 階級値を求める dplyr::mutate(class_value = as.character(class)) %&gt;% tidyr::separate(class_value, into = c(&quot;l&quot;, &quot;h&quot;), sep = &quot;,&quot;) %&gt;% dplyr::mutate(l = as.integer(stringr::str_remove(l, &quot;[[:punct:]]&quot;)) + 1L, h = as.integer(stringr::str_remove(h, &quot;[[:punct:]]&quot;)), mids = (l + h) / 2L) %&gt;% # 変数名を日本語にする dplyr::select(`階級` = class, `階級値` = mids, `度数` = n, `累積度数` = cumsum_n, `相対度数` = prop, `累積相対度数` = cumsum_prop) 1.2.1 階級を求める 以降に出てくるwith()関数は、第一引数で指定するデータフレーム型変数内の変数名を第二引数内で参照演算子（$）を用いることなく参照できるようにする関数です。 階級を求めるにはpretty()関数を使います。 with(x, pretty(x = height, n = nclass.Sturges(height))) ## [1] 140 145 150 155 160 165 170 第一引数xには階級を求めたいベクトル型データを第二引数nには階級を区切りたい数（階級数）を指定します。ここでは、階級数nにはスタージェスの公式から求めた階級数を指定しています。 ただし、必ずしも指定した階級数に分割される訳ではない点に注意してください。xで指定したデータが階級に収まるように適切な丸め処理を行いますので、指定した階級数とは異なる階級が求められることもあります。 スタージェスの公式は、階級数を\\(k\\)、データのサイズ（数）を\\(n\\)とした場合、下式で定義されます。 \\[k = \\log_2(n) + 1\\] スタージェスの公式はnclass.Sturgess()関数として実装されています。 with(x, nclass.Sturges(height)) ## [1] 8 スタージェスの公式以外にもスコットの選択（nclass.scott()）やフリードマン=ダイアコニスの選択（nclass.FD()）などがあります。 1.2.2 データを各階級に分類する データを階級分けするにはcut()関数を使います。 with(x, cut(x = height, breaks = pretty(height, n = nclass.Sturges(height)))) ## [1] (150,155] (150,155] (155,160] (155,160] (160,165] (155,160] (155,160] ## [8] (155,160] (150,155] (155,160] (150,155] (160,165] (155,160] (160,165] ## [15] (155,160] (160,165] (160,165] (165,170] (145,150] (160,165] (150,155] ## [22] (160,165] (155,160] (160,165] (165,170] (150,155] (155,160] (150,155] ## [29] (155,160] (155,160] (155,160] (145,150] (160,165] (150,155] (155,160] ## [36] (160,165] (150,155] (160,165] (150,155] (150,155] (150,155] (150,155] ## [43] (155,160] (145,150] (145,150] (160,165] (165,170] (150,155] (150,155] ## [50] (165,170] (160,165] (160,165] (145,150] (140,145] (155,160] (160,165] ## [57] (155,160] (155,160] (155,160] (160,165] (165,170] (155,160] (155,160] ## [64] (150,155] (155,160] (155,160] (150,155] (155,160] (150,155] (155,160] ## [71] (145,150] (165,170] (150,155] (155,160] (155,160] (155,160] (160,165] ## [78] (155,160] (155,160] (160,165] ## Levels: (140,145] (145,150] (150,155] (155,160] (160,165] (165,170] 第一引数xには階級分けの対象となるベクトル型変数を第二引数breaksには上記で求めた階級を指定します。こことではpretty()関数の結果を指定していますが、任意の階級を指定することもできます。 階級の境界値はどちらに含まれるのか？ cut()関数の出力は、(140,145] (145,150]のように階級間で同じ数値、この場合は145が含まれます。では、145はどちらの階級に含まれるのでしょうか？ 答えは、添えられている括弧にあります。 (140,145] は「140を超えて145以下」となりますので、次の (145,150] は同様に「145を超えて150以下」となります。階級間の境界値である145は(140, 145]側に入ります。 つまり (は「超えて」（境界値を含まない）、[は「以上」（境界値を含む） となっています。逆向きの括弧も同様で )は未満」（境界値を含まない）、]は「以下」（境界値を含む） となります。 境界値をどちらに含めるかはinclude.lowest引数とright引数で指定します。 option right = TRUE right = FALSE include.lowest = TRUE [l,u] ... (l,u] [l,u) ... [l,u] include.lowest = FALSE (l,u] ... (l,u] [l,u) ... [l,u) デフォルトは下記の通りです。 cut(x, breaks, include.lowest = FALSE, right = TRUE) 例えばデータの最大値と最小値を境界値として含む階級を指定した場合、include.lowest = FALSE, right = FALSEと指定すると最大値が階級に含まれなくなります。 with(x, cut(height, breaks = c(143, 155, 169), include.lowest = FALSE, right = FALSE)) ## [1] [143,155) [143,155) [155,169) [155,169) [155,169) [155,169) [155,169) ## [8] [155,169) [143,155) [155,169) [143,155) [155,169) [155,169) [155,169) ## [15] [155,169) [155,169) [155,169) &lt;NA&gt; [143,155) [155,169) [143,155) ## [22] [155,169) [155,169) [155,169) [155,169) [143,155) [155,169) [155,169) ## [29] [155,169) [155,169) [155,169) [143,155) [155,169) [155,169) [155,169) ## [36] [155,169) [143,155) [155,169) [143,155) [143,155) [143,155) [155,169) ## [43] [155,169) [143,155) [143,155) [155,169) &lt;NA&gt; [143,155) [155,169) ## [50] [155,169) [155,169) [155,169) [143,155) [143,155) [155,169) [155,169) ## [57] [155,169) [155,169) [155,169) [155,169) [155,169) [155,169) [155,169) ## [64] [143,155) [155,169) [155,169) [143,155) [155,169) [143,155) [155,169) ## [71] [143,155) [155,169) [143,155) [155,169) [155,169) [155,169) [155,169) ## [78] [155,169) [155,169) [155,169) ## Levels: [143,155) [155,169) 逆にinclude.lowest = FALSE, right = TRUEと指定すると最小値が階級に含まれなくなります。 with(x, cut(height, breaks = c(143, 155, 169), include.lowest = FALSE, right = TRUE)) ## [1] (143,155] (143,155] (155,169] (155,169] (155,169] (155,169] (155,169] ## [8] (155,169] (143,155] (155,169] (143,155] (155,169] (155,169] (155,169] ## [15] (155,169] (155,169] (155,169] (155,169] (143,155] (155,169] (143,155] ## [22] (155,169] (155,169] (155,169] (155,169] (143,155] (155,169] (143,155] ## [29] (155,169] (155,169] (155,169] (143,155] (155,169] (143,155] (155,169] ## [36] (155,169] (143,155] (155,169] (143,155] (143,155] (143,155] (143,155] ## [43] (155,169] (143,155] (143,155] (155,169] (155,169] (143,155] (143,155] ## [50] (155,169] (155,169] (155,169] (143,155] &lt;NA&gt; (155,169] (155,169] ## [57] (155,169] (155,169] (155,169] (155,169] (155,169] (155,169] (155,169] ## [64] (143,155] (155,169] (155,169] (143,155] (155,169] (143,155] (155,169] ## [71] (143,155] (155,169] (143,155] (155,169] (155,169] (155,169] (155,169] ## [78] (155,169] (155,169] (155,169] ## Levels: (143,155] (155,169] 1.2.3 度数を求める 度数を求めるには各階級の数を数えます。数を数えるにはtable()関数やdplyr::count()関数を使います。table()関数はベクトル型を対象に、dplyr::count()関数はデータフレーム型を対象として個数をカウントします。用途によって使い分けてください。 with(x, table(cut(height, breaks = pretty(height, n = nclass.Sturges(height))))) ## ## (140,145] (145,150] (150,155] (155,160] (160,165] (165,170] ## 1 6 19 30 18 6 x %&gt;% # 階級を求めて、データを階級ごとに分ける dplyr::mutate(class = cut(height, breaks = pretty(height, n = nclass.Sturges(height)))) %&gt;% # 階級ごとの度数を求める dplyr::count(class) 1.2.4 累積度数、相対度数、累積相対度数を求める 累積度数（度数の累積和）を求めるにはcumsum()関数を使います。 with(x, cumsum(table(cut(height, breaks = pretty(height, n = nclass.Sturges(height)))))) ## (140,145] (145,150] (150,155] (155,160] (160,165] (165,170] ## 1 7 26 56 74 80 相対度数を求めるにはprop.table()関数を使います。 with(x, prop.table(table(cut(height, breaks = pretty(height, n = nclass.Sturges(height)))))) ## ## (140,145] (145,150] (150,155] (155,160] (160,165] (165,170] ## 0.0125 0.0750 0.2375 0.3750 0.2250 0.0750 累積相対度数は相対度数の累積和ですので、prop.table()関数の結果をcumsum()関数に渡すことで求めることができます。 with(x, cumsum(prop.table(table(cut(height, breaks = pretty(height, n = nclass.Sturges(height))))))) ## (140,145] (145,150] (150,155] (155,160] (160,165] (165,170] ## 0.0125 0.0875 0.3250 0.7000 0.9250 1.0000 1.2.5 階級値を求める 階級値は階級の文字列から下限と上限の境界値を抜き出し、下式で単純平均として求めています。 \\[\\frac{(\\mbox{下限} + 1) + \\mbox{上限}}{2}\\] 手順としては以下のようにしています。 as.character()関数で 階級（class）を文字型に変換し、新しい変数（class_value）を作成する tidyr::separate()関数で文字型の変数（class_value）を,の前後で二つの変数（l, h）に分割する stringr::str_remove関数で二つの変数（l, h）から(や]を取り除きas.numeric()関数で文字列から数値に変換する 数値に変換された二つの変数から（l, h）平均値を求める x %&gt;% # 階級を求めて、データを階級ごとに分ける dplyr::mutate(class = cut(height, breaks = pretty(height, n = nclass.Sturges(height)), include.lowest = FALSE, right = TRUE)) %&gt;% # 階級ごとの度数を求める dplyr::count(class) %&gt;% # 階級値を求める dplyr::mutate(class_value = as.character(class)) %&gt;% tidyr::separate(class_value, into = c(&quot;l&quot;, &quot;h&quot;), sep = &quot;,&quot;) %&gt;% dplyr::mutate(l = as.numeric(stringr::str_remove(l, &quot;[[:punct:]]&quot;)), h = as.numeric(stringr::str_remove(h, &quot;[[:punct:]]&quot;))) %&gt;% dplyr::mutate(mids = ((l + 1) + h) / 2) 1.3 練習問題 テキストP23にあるデータで度数分布表とヒストグラムを作成する。 解答例 まず、処理しやすいように下記のように対象データを変形しdfというデータフレーム型の変数に格納しておきます。 df 度数分布表を身長の場合と同じ要領で作成します。 df %&gt;% # 階級を求めて、データを階級ごとに分ける dplyr::mutate(class = cut(weight, breaks = pretty(weight, n = nclass.Sturges(weight)), include.lowest = FALSE, right = TRUE)) %&gt;% # 階級ごとの度数を求める dplyr::count(class) %&gt;% # 累積度数、相対度数、累積相対度数を求める dplyr::mutate(cumsum_n = cumsum(n), prop = prop.table(n), cumsum_prop = cumsum(prop)) %&gt;% # 階級値を求める dplyr::mutate(class_value = as.character(class)) %&gt;% tidyr::separate(class_value, into = c(&quot;l&quot;, &quot;h&quot;), sep = &quot;,&quot;) %&gt;% dplyr::mutate(l = as.integer(stringr::str_remove(l, &quot;[[:punct:]]&quot;)) + 1L, h = as.integer(stringr::str_remove(h, &quot;[[:punct:]]&quot;)), mids = (l + h) / 2L) %&gt;% # 変数名を日本語にする dplyr::select(`階級` = class, `階級値` = mids, `度数` = n, `累積度数` = cumsum_n, `相対度数` = prop, `累積相対度数` = cumsum_prop) ヒストグラムを描きます。 with(df, hist(weight)) 以上 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
